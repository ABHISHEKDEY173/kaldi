diff --git a/egs/wsj/s5/steps/nnet3/ctc/align.sh b/egs/wsj/s5/steps/nnet3/ctc/align.sh
index 7194796..23a7b64 100644
--- a/egs/wsj/s5/steps/nnet3/ctc/align.sh
+++ b/egs/wsj/s5/steps/nnet3/ctc/align.sh
@@ -119,9 +119,9 @@ echo "$0: aligning data in $data using model from $srcdir, putting alignments in
 tra="ark:utils/sym2int.pl --map-oov $oov -f 2- $lang/words.txt $sdata/JOB/text|";
 
 $cmd JOB=1:$nj $dir/log/align.JOB.log \
-  compile-train-graphs $dir/tree $srcdir/${iter}.mdl  $lang/L.fst "$tra" ark:- \| \
-  nnet3-align-compiled $scale_opts $ivector_opts \
-    --use-gpu=$use_gpu --beam=$beam --retry-beam=$retry_beam \
+  compile-train-graphs-cctc $dir/tree $srcdir/${iter}.mdl  $lang/L.fst "$tra" ark:- \| \
+  nnet3-align-compiled-cctc $scale_opts $ivector_opts \
+    --beam=$beam --retry-beam=$retry_beam \
     $srcdir/${iter}.mdl ark:- "$feats" "ark:|gzip -c >$dir/ali.JOB.gz" || exit 1;
 
 echo "$0: done aligning data."
diff --git a/src/bin/Makefile b/src/bin/Makefile
index ac175e4..e5de771 100644
--- a/src/bin/Makefile
+++ b/src/bin/Makefile
@@ -3,7 +3,7 @@ all:
 EXTRA_CXXFLAGS = -Wno-sign-compare
 include ../kaldi.mk
 
-BINFILES = align-equal align-equal-compiled acc-tree-stats \
+#BINFILES = align-equal align-equal-compiled acc-tree-stats \
         show-alignments compile-questions cluster-phones \
         compute-wer make-h-transducer add-self-loops convert-ali \
         compile-train-graphs compile-train-graphs-fsts arpa2fst \
@@ -22,7 +22,7 @@ BINFILES = align-equal align-equal-compiled acc-tree-stats \
         matrix-logprob matrix-sum latgen-tracking-mapped \
         build-pfile-from-ali get-post-on-ali tree-info am-info \
         vector-sum matrix-sum-rows est-pca sum-lda-accs sum-mllt-accs \
-        transform-vec align-text matrix-dim
+        transform-vec align-text matrix-dim ali-to-pdf-fake
 
 
 OBJFILES =
diff --git a/src/bin/ali-to-pdf-fake.cc b/src/bin/ali-to-pdf-fake.cc
new file mode 100644
index 0000000..7ffcb32
--- /dev/null
+++ b/src/bin/ali-to-pdf-fake.cc
@@ -0,0 +1,76 @@
+// bin/ali-to-pdf.cc
+
+// Copyright 2009-2011  Microsoft Corporation
+
+// See ../../COPYING for clarification regarding multiple authors
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//  http://www.apache.org/licenses/LICENSE-2.0
+//
+// THIS CODE IS PROVIDED *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+// KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
+// WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
+// MERCHANTABLITY OR NON-INFRINGEMENT.
+// See the Apache 2 License for the specific language governing permissions and
+// limitations under the License.
+
+/** @brief Converts alignments (containing transition-ids) to pdf-ids, zero-based.
+*/
+#include "base/kaldi-common.h"
+#include "gmm/am-diag-gmm.h"
+#include "hmm/transition-model.h"
+#include "hmm/hmm-utils.h"
+#include "util/common-utils.h"
+#include "fst/fstlib.h"
+
+int main(int argc, char *argv[]) {
+  using namespace kaldi;
+  typedef kaldi::int32 int32;
+  try {
+    const char *usage =
+        "Converts alignments (containing transition-ids) to pdf-ids, zero-based.\n"
+        "Usage:  ali-to-pdf  [options] <model> <alignments-rspecifier> <pdfs-wspecifier>\n"
+        "e.g.: \n"
+        " ali-to-pdf 1.mdl ark:1.ali ark, t:-\n";
+    ParseOptions po(usage);
+
+    po.Read(argc, argv);
+
+    if (po.NumArgs() != 3) {
+      po.PrintUsage();
+      exit(1);
+    }
+
+    std::string model_filename = po.GetArg(1),
+        alignments_rspecifier = po.GetArg(2),
+        pdfs_wspecifier = po.GetArg(3);
+
+    TransitionModel trans_model;
+    ReadKaldiObject(model_filename, &trans_model);
+
+    SequentialInt32VectorReader reader(alignments_rspecifier);
+
+    Int32VectorWriter writer(pdfs_wspecifier);
+    int32 num_done = 0;
+    for (; !reader.Done(); reader.Next()) {
+      std::string key = reader.Key();
+      std::vector<int32> alignment = reader.Value();
+
+      for (size_t i = 0; i < alignment.size(); i++)
+          //alignment[i] = trans_model.TransitionIdToPdf(alignment[i]);
+          alignment[i] = 0;
+
+      writer.Write(key, alignment);
+      num_done++;
+    }
+    KALDI_LOG << "Converted " << num_done << " alignments to pdf sequences.";
+  } catch(const std::exception &e) {
+    std::cerr << e.what();
+    return -1;
+  }
+}
+
+
diff --git a/src/ctc/Makefile b/src/ctc/Makefile
index 5f21ba8..b74ad44 100644
--- a/src/ctc/Makefile
+++ b/src/ctc/Makefile
@@ -11,7 +11,7 @@ TESTFILES = language-model-test cctc-transition-model-test \
 
 OBJFILES = language-model.o cctc-transition-model.o cctc-graph.o \
            cctc-supervision.o cctc-training.o cctc-test-utils.o \
-           cctc-decoder-wrappers.o
+           cctc-decoder-wrappers.o training-graph-compiler.o lattice-functions.o posterior.o
 
 LIBNAME = kaldi-ctc
 
diff --git a/src/ctc/lattice-functions.cc b/src/ctc/lattice-functions.cc
new file mode 100644
index 0000000..4494156
--- /dev/null
+++ b/src/ctc/lattice-functions.cc
@@ -0,0 +1,1867 @@
+// lat/lattice-functions.cc
+
+// Copyright 2009-2011  Saarland University (Author: Arnab Ghoshal)
+//           2012-2013  Johns Hopkins University (Author: Daniel Povey);  Chao Weng;
+//                      Bagher BabaAli
+//                2013  Cisco Systems (author: Neha Agrawal) [code modified
+//                      from original code in ../gmmbin/gmm-rescore-lattice.cc]
+//                2014  Guoguo Chen
+
+// See ../../COPYING for clarification regarding multiple authors
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//  http://www.apache.org/licenses/LICENSE-2.0
+//
+// THIS CODE IS PROVIDED *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+// KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
+// WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
+// MERCHANTABLITY OR NON-INFRINGEMENT.
+// See the Apache 2 License for the specific language governing permissions and
+// limitations under the License.
+
+
+#include "ctc/lattice-functions.h"
+#include "hmm/transition-model.h"
+#include "util/stl-utils.h"
+#include "base/kaldi-math.h"
+#include "hmm/hmm-utils.h"
+
+
+namespace kaldi {
+namespace ctc {
+using std::map;
+using std::vector;
+
+int32 LatticeStateTimes(const Lattice &lat, vector<int32> *times) {
+  if (!lat.Properties(fst::kTopSorted, true))
+    KALDI_ERR << "Input lattice must be topologically sorted.";
+  KALDI_ASSERT(lat.Start() == 0);
+  int32 num_states = lat.NumStates();
+  times->clear();
+  times->resize(num_states, -1);
+  (*times)[0] = 0;
+  for (int32 state = 0; state < num_states; state++) {
+    int32 cur_time = (*times)[state];
+    for (fst::ArcIterator<Lattice> aiter(lat, state); !aiter.Done();
+        aiter.Next()) {
+      const LatticeArc &arc = aiter.Value();
+
+      if (arc.ilabel != 0) {  // Non-epsilon input label on arc
+        // next time instance
+        if ((*times)[arc.nextstate] == -1) {
+          (*times)[arc.nextstate] = cur_time + 1;
+        } else {
+          KALDI_ASSERT((*times)[arc.nextstate] == cur_time + 1);
+        }
+      } else {  // epsilon input label on arc
+        // Same time instance
+        if ((*times)[arc.nextstate] == -1)
+          (*times)[arc.nextstate] = cur_time;
+        else
+          KALDI_ASSERT((*times)[arc.nextstate] == cur_time);
+      }
+    }
+  }
+  return (*std::max_element(times->begin(), times->end()));
+}
+
+int32 CompactLatticeStateTimes(const CompactLattice &lat, vector<int32> *times) {
+  if (!lat.Properties(fst::kTopSorted, true))
+    KALDI_ERR << "Input lattice must be topologically sorted.";
+  KALDI_ASSERT(lat.Start() == 0);
+  int32 num_states = lat.NumStates();
+  times->clear();
+  times->resize(num_states, -1);
+  (*times)[0] = 0;
+  int32 utt_len = -1;
+  for (int32 state = 0; state < num_states; state++) {
+    int32 cur_time = (*times)[state];
+    for (fst::ArcIterator<CompactLattice> aiter(lat, state); !aiter.Done();
+        aiter.Next()) {
+      const CompactLatticeArc &arc = aiter.Value();
+      int32 arc_len = static_cast<int32>(arc.weight.String().size());
+      if ((*times)[arc.nextstate] == -1)
+        (*times)[arc.nextstate] = cur_time + arc_len;
+      else
+        KALDI_ASSERT((*times)[arc.nextstate] == cur_time + arc_len);
+    }
+    if (lat.Final(state) != CompactLatticeWeight::Zero()) {
+      int32 this_utt_len = (*times)[state] + lat.Final(state).String().size();
+      if (utt_len == -1) utt_len = this_utt_len;
+      else {
+        if (this_utt_len != utt_len) {
+          KALDI_WARN << "Utterance does not "
+              "seem to have a consistent length.";
+          utt_len = std::max(utt_len, this_utt_len);
+        }
+      }
+    }
+  }
+  if (utt_len == -1) {
+    KALDI_WARN << "Utterance does not have a final-state.";
+    return 0;
+  }
+  return utt_len;
+}
+
+bool ComputeCompactLatticeAlphas(const CompactLattice &clat,
+                                 vector<double> *alpha) {
+  using namespace fst;
+
+  // typedef the arc, weight types
+  typedef CompactLattice::Arc Arc;
+  typedef Arc::Weight Weight;
+  typedef Arc::StateId StateId;
+
+  //Make sure the lattice is topologically sorted.
+  if (clat.Properties(fst::kTopSorted, true) == 0) {
+    KALDI_WARN << "Input lattice must be topologically sorted.";
+    return false;
+  }
+  if (clat.Start() != 0) {
+    KALDI_WARN << "Input lattice must start from state 0.";
+    return false;
+  }
+
+  int32 num_states = clat.NumStates();
+  (*alpha).resize(0);
+  (*alpha).resize(num_states, kLogZeroDouble);
+
+  // Now propagate alphas forward. Note that we don't acount the weight of the
+  // final state to alpha[final_state] -- we acount it to beta[final_state];
+  (*alpha)[0] = 0.0;
+  for (StateId s = 0; s < num_states; s++) {
+    double this_alpha = (*alpha)[s];
+    for (ArcIterator<CompactLattice> aiter(clat, s); !aiter.Done(); aiter.Next()) {
+      const Arc &arc = aiter.Value();
+      double arc_like = -(arc.weight.Weight().Value1() + arc.weight.Weight().Value2());
+      (*alpha)[arc.nextstate] = LogAdd((*alpha)[arc.nextstate], this_alpha + arc_like);
+    }
+  }
+
+  return true;
+}
+
+bool ComputeCompactLatticeBetas(const CompactLattice &clat,
+                                vector<double> *beta) {
+  using namespace fst;
+
+  // typedef the arc, weight types
+  typedef CompactLattice::Arc Arc;
+  typedef Arc::Weight Weight;
+  typedef Arc::StateId StateId;
+
+  // Make sure the lattice is topologically sorted.
+  if (clat.Properties(fst::kTopSorted, true) == 0) {
+    KALDI_WARN << "Input lattice must be topologically sorted.";
+    return false;
+  }
+  if (clat.Start() != 0) {
+    KALDI_WARN << "Input lattice must start from state 0.";
+    return false;
+  }
+
+  int32 num_states = clat.NumStates();
+  (*beta).resize(0);
+  (*beta).resize(num_states, kLogZeroDouble);
+
+  // Now propagate betas backward. Note that beta[final_state] contains the
+  // weight of the final state in the lattice -- compare that with alpha.
+  for (StateId s = num_states-1; s >= 0; s--) {
+    Weight f = clat.Final(s);
+    double this_beta = -(f.Weight().Value1()+f.Weight().Value2());
+    for (ArcIterator<CompactLattice> aiter(clat, s); !aiter.Done(); aiter.Next()) {
+      const Arc &arc = aiter.Value();
+      double arc_like = -(arc.weight.Weight().Value1()+arc.weight.Weight().Value2());
+      double arc_beta = (*beta)[arc.nextstate] + arc_like;
+      this_beta = LogAdd(this_beta, arc_beta);
+    }
+    (*beta)[s] = this_beta;
+  }
+
+  return true;
+}
+
+template<class LatType>  // could be Lattice or CompactLattice
+bool PruneLattice(BaseFloat beam, LatType *lat) {
+  typedef typename LatType::Arc Arc;
+  typedef typename Arc::Weight Weight;
+  typedef typename Arc::StateId StateId;
+
+  KALDI_ASSERT(beam > 0.0);
+  if (!lat->Properties(fst::kTopSorted, true)) {
+    if (fst::TopSort(lat) == false) {
+      KALDI_WARN << "Cycles detected in lattice";
+      return false;
+    }
+  }
+  // We assume states before "start" are not reachable, since
+  // the lattice is topologically sorted.
+  int32 start = lat->Start();
+  int32 num_states = lat->NumStates();
+  if (num_states == 0) return false;
+  std::vector<double> forward_cost(num_states,
+                                   std::numeric_limits<double>::infinity());  // viterbi forward.
+  forward_cost[start] = 0.0; // lattice can't have cycles so couldn't be
+  // less than this.
+  double best_final_cost = std::numeric_limits<double>::infinity();
+  // Update the forward probs.
+  // Thanks to Jing Zheng for finding a bug here.
+  for (int32 state = 0; state < num_states; state++) {
+    double this_forward_cost = forward_cost[state];
+    for (fst::ArcIterator<LatType> aiter(*lat, state);
+         !aiter.Done();
+         aiter.Next()) {
+      const Arc &arc(aiter.Value());
+      StateId nextstate = arc.nextstate;
+      KALDI_ASSERT(nextstate > state && nextstate < num_states);
+      double next_forward_cost = this_forward_cost +
+          ConvertToCost(arc.weight);
+      if (forward_cost[nextstate] > next_forward_cost)
+        forward_cost[nextstate] = next_forward_cost;
+    }
+    Weight final_weight = lat->Final(state);
+    double this_final_cost = this_forward_cost +
+        ConvertToCost(final_weight);
+    if (this_final_cost < best_final_cost)
+      best_final_cost = this_final_cost;
+  }
+  int32 bad_state = lat->AddState(); // this state is not final.
+  double cutoff = best_final_cost + beam;
+
+  // Go backwards updating the backward probs (which share memory with the
+  // forward probs), and pruning arcs and deleting final-probs.  We prune arcs
+  // by making them point to the non-final state "bad_state".  We'll then use
+  // Trim() to remove unnecessary arcs and states.  [this is just easier than
+  // doing it ourselves.]
+  std::vector<double> &backward_cost(forward_cost);
+  for (int32 state = num_states - 1; state >= 0; state--) {
+    double this_forward_cost = forward_cost[state];
+    double this_backward_cost = ConvertToCost(lat->Final(state));
+    if (this_backward_cost + this_forward_cost > cutoff
+        && this_backward_cost != std::numeric_limits<double>::infinity())
+      lat->SetFinal(state, Weight::Zero());
+    for (fst::MutableArcIterator<LatType> aiter(lat, state);
+         !aiter.Done();
+         aiter.Next()) {
+      Arc arc(aiter.Value());
+      StateId nextstate = arc.nextstate;
+      KALDI_ASSERT(nextstate > state && nextstate < num_states);
+      double arc_cost = ConvertToCost(arc.weight),
+          arc_backward_cost = arc_cost + backward_cost[nextstate],
+          this_fb_cost = this_forward_cost + arc_backward_cost;
+      if (arc_backward_cost < this_backward_cost)
+        this_backward_cost = arc_backward_cost;
+      if (this_fb_cost > cutoff) { // Prune the arc.
+        arc.nextstate = bad_state;
+        aiter.SetValue(arc);
+      }
+    }
+    backward_cost[state] = this_backward_cost;
+  }
+  fst::Connect(lat);
+  return (lat->NumStates() > 0);
+}
+
+// instantiate the template for lattice and CompactLattice.
+template bool PruneLattice(BaseFloat beam, Lattice *lat);
+template bool PruneLattice(BaseFloat beam, CompactLattice *lat);
+
+
+BaseFloat LatticeForwardBackward(const Lattice &lat, Posterior *post,
+                                 double *acoustic_like_sum) {
+  // Note, Posterior is defined as follows:  Indexed [frame], then a list
+  // of (transition-id, posterior-probability) pairs.
+  // typedef std::vector<std::vector<std::pair<int32, BaseFloat> > > Posterior;
+  using namespace fst;
+  typedef Lattice::Arc Arc;
+  typedef Arc::Weight Weight;
+  typedef Arc::StateId StateId;
+
+  if (acoustic_like_sum) *acoustic_like_sum = 0.0;
+
+  // Make sure the lattice is topologically sorted.
+  if (lat.Properties(fst::kTopSorted, true) == 0)
+    KALDI_ERR << "Input lattice must be topologically sorted.";
+  KALDI_ASSERT(lat.Start() == 0);
+
+  int32 num_states = lat.NumStates();
+  vector<int32> state_times;
+  int32 max_time = LatticeStateTimes(lat, &state_times);
+  std::vector<double> alpha(num_states, kLogZeroDouble);
+  std::vector<double> &beta(alpha); // we re-use the same memory for
+  // this, but it's semantically distinct so we name it differently.
+  double tot_forward_prob = kLogZeroDouble;
+
+  post->clear();
+  post->resize(max_time);
+
+  alpha[0] = 0.0;
+  // Propagate alphas forward.
+  for (StateId s = 0; s < num_states; s++) {
+    double this_alpha = alpha[s];
+    for (ArcIterator<Lattice> aiter(lat, s); !aiter.Done(); aiter.Next()) {
+      const Arc &arc = aiter.Value();
+      double arc_like = -ConvertToCost(arc.weight);
+      alpha[arc.nextstate] = LogAdd(alpha[arc.nextstate], this_alpha + arc_like);
+    }
+    Weight f = lat.Final(s);
+    if (f != Weight::Zero()) {
+      double final_like = this_alpha - (f.Value1() + f.Value2());
+      tot_forward_prob = LogAdd(tot_forward_prob, final_like);
+      KALDI_ASSERT(state_times[s] == max_time &&
+                   "Lattice is inconsistent (final-prob not at max_time)");
+    }
+  }
+  for (StateId s = num_states-1; s >= 0; s--) {
+    Weight f = lat.Final(s);
+    double this_beta = -(f.Value1() + f.Value2());
+    for (ArcIterator<Lattice> aiter(lat, s); !aiter.Done(); aiter.Next()) {
+      const Arc &arc = aiter.Value();
+      double arc_like = -ConvertToCost(arc.weight),
+          arc_beta = beta[arc.nextstate] + arc_like;
+      this_beta = LogAdd(this_beta, arc_beta);
+      int32 transition_id = arc.ilabel;
+
+      // The following "if" is an optimization to avoid un-needed exp().
+      if (transition_id != 0 || acoustic_like_sum != NULL) {
+        double posterior = Exp(alpha[s] + arc_beta - tot_forward_prob);
+
+        if (transition_id != 0) // Arc has a transition-id on it [not epsilon]
+          (*post)[state_times[s]].push_back(std::make_pair(transition_id,
+                                                           static_cast<kaldi::BaseFloat>(posterior)));
+        if (acoustic_like_sum != NULL)
+          *acoustic_like_sum -= posterior * arc.weight.Value2();
+      }
+    }
+    if (acoustic_like_sum != NULL && f != Weight::Zero()) {
+      double final_logprob = - ConvertToCost(f),
+          posterior = Exp(alpha[s] + final_logprob - tot_forward_prob);
+      *acoustic_like_sum -= posterior * f.Value2();
+    }
+    beta[s] = this_beta;
+  }
+  double tot_backward_prob = beta[0];
+  if (!ApproxEqual(tot_forward_prob, tot_backward_prob, 1e-8)) {
+    KALDI_WARN << "Total forward probability over lattice = " << tot_forward_prob
+              << ", while total backward probability = " << tot_backward_prob;
+  }
+  // Now combine any posteriors with the same transition-id.
+  for (int32 t = 0; t < max_time; t++)
+    MergePairVectorSumming(&((*post)[t]));
+  return tot_backward_prob;
+}
+
+
+void LatticeActivePhones(const Lattice &lat, const TransitionModel &trans,
+                         const vector<int32> &silence_phones,
+                         vector< std::set<int32> > *active_phones) {
+  KALDI_ASSERT(IsSortedAndUniq(silence_phones));
+  vector<int32> state_times;
+  int32 num_states = lat.NumStates();
+  int32 max_time = LatticeStateTimes(lat, &state_times);
+  active_phones->clear();
+  active_phones->resize(max_time);
+  for (int32 state = 0; state < num_states; state++) {
+    int32 cur_time = state_times[state];
+    for (fst::ArcIterator<Lattice> aiter(lat, state); !aiter.Done();
+        aiter.Next()) {
+      const LatticeArc &arc = aiter.Value();
+      if (arc.ilabel != 0) {  // Non-epsilon arc
+        int32 phone = trans.TransitionIdToPhone(arc.ilabel);
+        if (!std::binary_search(silence_phones.begin(),
+                                silence_phones.end(), phone))
+          (*active_phones)[cur_time].insert(phone);
+      }
+    }  // end looping over arcs
+  }  // end looping over states
+}
+
+void ConvertLatticeToPhones(const TransitionModel &trans,
+                            Lattice *lat) {
+  typedef LatticeArc Arc;
+  int32 num_states = lat->NumStates();
+  for (int32 state = 0; state < num_states; state++) {
+    for (fst::MutableArcIterator<Lattice> aiter(lat, state); !aiter.Done();
+        aiter.Next()) {
+      Arc arc(aiter.Value());
+      arc.olabel = 0; // remove any word.
+      if ((arc.ilabel != 0) // has a transition-id on input..
+          && (trans.TransitionIdToHmmState(arc.ilabel) == 0)
+          && (!trans.IsSelfLoop(arc.ilabel)))
+         // && trans.IsFinal(arc.ilabel)) // there is one of these per phone...
+        arc.olabel = trans.TransitionIdToPhone(arc.ilabel);
+      aiter.SetValue(arc);
+    }  // end looping over arcs
+  }  // end looping over states
+}
+
+
+static inline double LogAddOrMax(bool viterbi, double a, double b) {
+  if (viterbi)
+    return std::max(a, b);
+  else
+    return LogAdd(a, b);
+}
+
+// Computes (normal or Viterbi) alphas and betas; returns (total-prob, or
+// best-path negated cost) Note: in either case, the alphas and betas are
+// negated costs.  Requires that lat be topologically sorted.  This code
+// will work for either CompactLattice or Latice.
+template<typename LatticeType>
+static double ComputeLatticeAlphasAndBetas(const LatticeType &lat,
+                                           bool viterbi,
+                                           vector<double> *alpha,
+                                           vector<double> *beta) {
+  typedef typename LatticeType::Arc Arc;
+  typedef typename Arc::Weight Weight;
+  typedef typename Arc::StateId StateId;
+
+  StateId num_states = lat.NumStates();
+  KALDI_ASSERT(lat.Properties(fst::kTopSorted, true) == fst::kTopSorted);
+  KALDI_ASSERT(lat.Start() == 0);
+  alpha->resize(num_states, kLogZeroDouble);
+  beta->resize(num_states, kLogZeroDouble);
+
+  double tot_forward_prob = kLogZeroDouble;
+  (*alpha)[0] = 0.0;
+  // Propagate alphas forward.
+  for (StateId s = 0; s < num_states; s++) {
+    double this_alpha = (*alpha)[s];
+    for (fst::ArcIterator<LatticeType> aiter(lat, s); !aiter.Done();
+         aiter.Next()) {
+      const Arc &arc = aiter.Value();
+      double arc_like = -ConvertToCost(arc.weight);
+      (*alpha)[arc.nextstate] = LogAddOrMax(viterbi, (*alpha)[arc.nextstate],
+                                                this_alpha + arc_like);
+    }
+    Weight f = lat.Final(s);
+    if (f != Weight::Zero()) {
+      double final_like = this_alpha - ConvertToCost(f);
+      tot_forward_prob = LogAddOrMax(viterbi, tot_forward_prob, final_like);
+    }
+  }
+  for (StateId s = num_states-1; s >= 0; s--) { // it's guaranteed signed.
+    double this_beta = -ConvertToCost(lat.Final(s));
+    for (fst::ArcIterator<LatticeType> aiter(lat, s); !aiter.Done();
+         aiter.Next()) {
+      const Arc &arc = aiter.Value();
+      double arc_like = -ConvertToCost(arc.weight),
+          arc_beta = (*beta)[arc.nextstate] + arc_like;
+      this_beta = LogAddOrMax(viterbi, this_beta, arc_beta);
+    }
+    (*beta)[s] = this_beta;
+  }
+  double tot_backward_prob = (*beta)[lat.Start()];
+  if (!ApproxEqual(tot_forward_prob, tot_backward_prob, 1e-8)) {
+    KALDI_WARN << "Total forward probability over lattice = " << tot_forward_prob
+               << ", while total backward probability = " << tot_backward_prob;
+  }
+  // Split the difference when returning... they should be the same.
+  return 0.5 * (tot_backward_prob + tot_forward_prob);
+}
+
+
+
+/// This is used in CompactLatticeLimitDepth.
+struct LatticeArcRecord {
+  BaseFloat logprob; // logprob <= 0 is the best Viterbi logprob of this arc,
+                     // minus the overall best-cost of the lattice.
+  CompactLatticeArc::StateId state; // state in the lattice.
+  size_t arc; // arc index within the state.
+  bool operator < (const LatticeArcRecord &other) const {
+    return logprob < other.logprob;
+  }
+};
+
+void CompactLatticeLimitDepth(int32 max_depth_per_frame,
+                              CompactLattice *clat) {
+  typedef CompactLatticeArc Arc;
+  typedef Arc::Weight Weight;
+  typedef Arc::StateId StateId;
+
+  if (clat->Start() == fst::kNoStateId) {
+    KALDI_WARN << "Limiting depth of empty lattice.";
+    return;
+  }
+  if (clat->Properties(fst::kTopSorted, true) == 0) {
+    if (!TopSort(clat))
+      KALDI_ERR << "Topological sorting of lattice failed.";
+  }
+
+  vector<int32> state_times;
+  int32 T = CompactLatticeStateTimes(*clat, &state_times);
+
+  // The alpha and beta quantities here are "viterbi" alphas and beta.
+  std::vector<double> alpha;
+  std::vector<double> beta;
+  bool viterbi = true;
+  double best_prob = ComputeLatticeAlphasAndBetas(*clat, viterbi,
+                                                  &alpha, &beta);
+
+  std::vector<std::vector<LatticeArcRecord> > arc_records(T);
+
+  StateId num_states = clat->NumStates();
+  for (StateId s = 0; s < num_states; s++) {
+    for (fst::ArcIterator<CompactLattice> aiter(*clat, s); !aiter.Done();
+         aiter.Next()) {
+      const Arc &arc = aiter.Value();
+      LatticeArcRecord arc_record;
+      arc_record.state = s;
+      arc_record.arc = aiter.Position();
+      arc_record.logprob =
+          (alpha[s] + beta[arc.nextstate] - ConvertToCost(arc.weight))
+           - best_prob;
+      KALDI_ASSERT(arc_record.logprob < 0.1); // Should be zero or negative.
+      int32 num_frames = arc.weight.String().size(), start_t = state_times[s];
+      for (int32 t = start_t; t < start_t + num_frames; t++) {
+        KALDI_ASSERT(t < T);
+        arc_records[t].push_back(arc_record);
+      }
+    }
+  }
+  StateId dead_state = clat->AddState(); // A non-coaccesible state which we use
+                                         // to remove arcs (make them end
+                                         // there).
+  size_t max_depth = max_depth_per_frame;
+  for (int32 t = 0; t < T; t++) {
+    size_t size = arc_records[t].size();
+    if (size > max_depth) {
+      // we sort from worst to best, so we keep the later-numbered ones,
+      // and delete the lower-numbered ones.
+      size_t cutoff = size - max_depth;
+      std::nth_element(arc_records[t].begin(),
+                       arc_records[t].begin() + cutoff,
+                       arc_records[t].end());
+      for (size_t index = 0; index < cutoff; index++) {
+        LatticeArcRecord record(arc_records[t][index]);
+        fst::MutableArcIterator<CompactLattice> aiter(clat, record.state);
+        aiter.Seek(record.arc);
+        Arc arc = aiter.Value();
+        if (arc.nextstate != dead_state) { // not already killed.
+          arc.nextstate = dead_state;
+          aiter.SetValue(arc);
+        }
+      }
+    }
+  }
+  Connect(clat);
+  TopSortCompactLatticeIfNeeded(clat);
+}
+
+
+void TopSortCompactLatticeIfNeeded(CompactLattice *clat) {
+  if (clat->Properties(fst::kTopSorted, true) == 0) {
+    if (fst::TopSort(clat) == false) {
+      KALDI_ERR << "Topological sorting failed";
+    }
+  }
+}
+
+void TopSortLatticeIfNeeded(Lattice *lat) {
+  if (lat->Properties(fst::kTopSorted, true) == 0) {
+    if (fst::TopSort(lat) == false) {
+      KALDI_ERR << "Topological sorting failed";
+    }
+  }
+}
+
+
+/// Returns the depth of the lattice, defined as the average number of
+/// arcs crossing any given frame.  Returns 1 for empty lattices.
+/// Requires that input is topologically sorted.
+BaseFloat CompactLatticeDepth(const CompactLattice &clat,
+                              int32 *num_frames) {
+  typedef CompactLattice::Arc::StateId StateId;
+  if (clat.Properties(fst::kTopSorted, true) == 0) {
+    KALDI_ERR << "Lattice input to CompactLatticeDepth was not topologically "
+              << "sorted.";
+  }
+  if (clat.Start() == fst::kNoStateId) {
+    *num_frames = 0;
+    return 1.0;
+  }
+  size_t num_arc_frames = 0;
+  int32 t;
+  {
+    vector<int32> state_times;
+    t = CompactLatticeStateTimes(clat, &state_times);
+  }
+  if (num_frames != NULL)
+    *num_frames = t;
+  for (StateId s = 0; s < clat.NumStates(); s++) {
+    for (fst::ArcIterator<CompactLattice> aiter(clat, s); !aiter.Done();
+         aiter.Next()) {
+      const CompactLatticeArc &arc = aiter.Value();
+      num_arc_frames += arc.weight.String().size();
+    }
+    num_arc_frames += clat.Final(s).String().size();
+  }
+  return num_arc_frames / static_cast<BaseFloat>(t);
+}
+
+
+void CompactLatticeDepthPerFrame(const CompactLattice &clat,
+                                 std::vector<int32> *depth_per_frame) {
+  typedef CompactLattice::Arc::StateId StateId;
+  if (clat.Properties(fst::kTopSorted, true) == 0) {
+    KALDI_ERR << "Lattice input to CompactLatticeDepthPerFrame was not "
+              << "topologically sorted.";
+  }
+  if (clat.Start() == fst::kNoStateId) {
+    depth_per_frame->clear();
+    return;
+  }
+  vector<int32> state_times;
+  int32 T = CompactLatticeStateTimes(clat, &state_times);
+
+  depth_per_frame->clear();
+  if (T <= 0) {
+    return;
+  } else {
+    depth_per_frame->resize(T, 0);
+    for (StateId s = 0; s < clat.NumStates(); s++) {
+      int32 start_time = state_times[s];
+      for (fst::ArcIterator<CompactLattice> aiter(clat, s); !aiter.Done();
+           aiter.Next()) {
+        const CompactLatticeArc &arc = aiter.Value();
+        int32 len = arc.weight.String().size();
+        for (int32 t = start_time; t < start_time + len; t++) {
+          KALDI_ASSERT(t < T);
+          (*depth_per_frame)[t]++;
+        }
+      }
+      int32 final_len = clat.Final(s).String().size();
+      for (int32 t = start_time; t < start_time + final_len; t++) {
+        KALDI_ASSERT(t < T);
+        (*depth_per_frame)[t]++;
+      }
+    }
+  }
+}
+
+
+
+void ConvertCompactLatticeToPhones(const TransitionModel &trans,
+                                   CompactLattice *clat) {
+  typedef CompactLatticeArc Arc;
+  typedef Arc::Weight Weight;
+  int32 num_states = clat->NumStates();
+  for (int32 state = 0; state < num_states; state++) {
+    for (fst::MutableArcIterator<CompactLattice> aiter(clat, state);
+         !aiter.Done();
+         aiter.Next()) {
+      Arc arc(aiter.Value());
+      std::vector<int32> phone_seq;
+      const std::vector<int32> &tid_seq = arc.weight.String();
+      for (std::vector<int32>::const_iterator iter = tid_seq.begin();
+           iter != tid_seq.end(); ++iter) {
+        if (trans.IsFinal(*iter))// note: there is one of these per phone...
+          phone_seq.push_back(trans.TransitionIdToPhone(*iter));
+      }
+      arc.weight.SetString(phone_seq);
+      aiter.SetValue(arc);
+    } // end looping over arcs
+    Weight f = clat->Final(state);
+    if (f != Weight::Zero()) {
+      std::vector<int32> phone_seq;
+      const std::vector<int32> &tid_seq = f.String();
+      for (std::vector<int32>::const_iterator iter = tid_seq.begin();
+           iter != tid_seq.end(); ++iter) {
+        if (trans.IsFinal(*iter))// note: there is one of these per phone...
+          phone_seq.push_back(trans.TransitionIdToPhone(*iter));
+      }
+      f.SetString(phone_seq);
+      clat->SetFinal(state, f);
+    }
+  }  // end looping over states
+}
+
+bool LatticeBoost(const TransitionModel &trans,
+                  const std::vector<int32> &alignment,
+                  const std::vector<int32> &silence_phones,
+                  BaseFloat b,
+                  BaseFloat max_silence_error,
+                  Lattice *lat) {
+  TopSortLatticeIfNeeded(lat);
+
+  // get all stored properties (test==false means don't test if not known).
+  uint64 props = lat->Properties(fst::kFstProperties,
+                                 false);
+
+  KALDI_ASSERT(IsSortedAndUniq(silence_phones));
+  KALDI_ASSERT(max_silence_error >= 0.0 && max_silence_error <= 1.0);
+  vector<int32> state_times;
+  int32 num_states = lat->NumStates();
+  int32 num_frames = LatticeStateTimes(*lat, &state_times);
+  KALDI_ASSERT(num_frames == static_cast<int32>(alignment.size()));
+  for (int32 state = 0; state < num_states; state++) {
+    int32 cur_time = state_times[state];
+    for (fst::MutableArcIterator<Lattice> aiter(lat, state); !aiter.Done();
+         aiter.Next()) {
+      LatticeArc arc = aiter.Value();
+      if (arc.ilabel != 0) {  // Non-epsilon arc
+        if (arc.ilabel < 0 || arc.ilabel > trans.NumTransitionIds()) {
+          KALDI_WARN << "Lattice has out-of-range transition-ids: "
+                     << "lattice/model mismatch?";
+          return false;
+        }
+        int32 phone = trans.TransitionIdToPhone(arc.ilabel),
+            ref_phone = trans.TransitionIdToPhone(alignment[cur_time]);
+        BaseFloat frame_error;
+        if (phone == ref_phone) {
+          frame_error = 0.0;
+        } else { // an error...
+          if (std::binary_search(silence_phones.begin(), silence_phones.end(), phone))
+            frame_error = max_silence_error;
+          else
+            frame_error = 1.0;
+        }
+        BaseFloat delta_cost = -b * frame_error; // negative cost if
+        // frame is wrong, to boost likelihood of arcs with errors on them.
+        // Add this cost to the graph part.
+        arc.weight.SetValue1(arc.weight.Value1() + delta_cost);
+        aiter.SetValue(arc);
+      }
+    }
+  }
+  // All we changed is the weights, so any properties that were
+  // known before, are still known, except for whether or not the
+  // lattice was weighted.
+  lat->SetProperties(props,
+                     ~(fst::kWeighted|fst::kUnweighted));
+
+  return true;
+}
+
+bool LatticeBoostCctc(const ctc::CctcTransitionModel &trans,
+                  const std::vector<int32> &alignment,
+                  const std::vector<int32> &silence_phones,
+                  BaseFloat b,
+                  BaseFloat max_silence_error,
+                  Lattice *lat) {
+  TopSortLatticeIfNeeded(lat);
+
+  // get all stored properties (test==false means don't test if not known).
+  uint64 props = lat->Properties(fst::kFstProperties,
+                                 false);
+
+  KALDI_ASSERT(IsSortedAndUniq(silence_phones));
+  KALDI_ASSERT(max_silence_error >= 0.0 && max_silence_error <= 1.0);
+  vector<int32> state_times;
+  int32 num_states = lat->NumStates();
+  int32 num_frames = LatticeStateTimes(*lat, &state_times);
+  KALDI_ASSERT(num_frames == static_cast<int32>(alignment.size()));
+  for (int32 state = 0; state < num_states; state++) {
+    int32 cur_time = state_times[state];
+    for (fst::MutableArcIterator<Lattice> aiter(lat, state); !aiter.Done();
+         aiter.Next()) {
+      LatticeArc arc = aiter.Value();
+      if (arc.ilabel != 0) {  // Non-epsilon arc
+        if (arc.ilabel < 0 || arc.ilabel > trans.NumGraphLabels()) {
+          KALDI_WARN << "Lattice has out-of-range transition-ids: "
+                     << "lattice/model mismatch?";
+          return false;
+        }
+        int32 phone = trans.GraphLabelToPhone(arc.ilabel),
+            ref_phone = trans.GraphLabelToPhone(alignment[cur_time]);
+        BaseFloat frame_error;
+        if (phone == ref_phone) {
+          frame_error = 0.0;
+        } else { // an error...
+          if (std::binary_search(silence_phones.begin(), silence_phones.end(), phone))
+            frame_error = max_silence_error;
+          else
+            frame_error = 1.0;
+        }
+        BaseFloat delta_cost = -b * frame_error; // negative cost if
+        // frame is wrong, to boost likelihood of arcs with errors on them.
+        // Add this cost to the graph part.
+        arc.weight.SetValue1(arc.weight.Value1() + delta_cost);
+        aiter.SetValue(arc);
+      }
+    }
+  }
+  // All we changed is the weights, so any properties that were
+  // known before, are still known, except for whether or not the
+  // lattice was weighted.
+  lat->SetProperties(props,
+                     ~(fst::kWeighted|fst::kUnweighted));
+
+  return true;
+}
+
+
+
+BaseFloat LatticeForwardBackwardMpeVariants(
+    const TransitionModel &trans,
+    const std::vector<int32> &silence_phones,
+    const Lattice &lat,
+    const std::vector<int32> &num_ali,
+    std::string criterion,
+    bool one_silence_class,
+    Posterior *post) {
+  using namespace fst;
+  typedef Lattice::Arc Arc;
+  typedef Arc::Weight Weight;
+  typedef Arc::StateId StateId;
+
+  KALDI_ASSERT(criterion == "mpfe" || criterion == "smbr");
+  bool is_mpfe = (criterion == "mpfe");
+
+  if (lat.Properties(fst::kTopSorted, true) == 0)
+    KALDI_ERR << "Input lattice must be topologically sorted.";
+  KALDI_ASSERT(lat.Start() == 0);
+
+  int32 num_states = lat.NumStates();
+  vector<int32> state_times;
+  int32 max_time = LatticeStateTimes(lat, &state_times);
+  KALDI_ASSERT(max_time == static_cast<int32>(num_ali.size()));
+  std::vector<double> alpha(num_states, kLogZeroDouble),
+      alpha_smbr(num_states, 0), //forward variable for sMBR
+      beta(num_states, kLogZeroDouble),
+      beta_smbr(num_states, 0); //backward variable for sMBR
+
+  double tot_forward_prob = kLogZeroDouble;
+  double tot_forward_score = 0;
+
+  post->clear();
+  post->resize(max_time);
+
+  alpha[0] = 0.0;
+  // First Pass Forward,
+  for (StateId s = 0; s < num_states; s++) {
+    double this_alpha = alpha[s];
+    for (ArcIterator<Lattice> aiter(lat, s); !aiter.Done(); aiter.Next()) {
+      const Arc &arc = aiter.Value();
+      double arc_like = -ConvertToCost(arc.weight);
+      alpha[arc.nextstate] = LogAdd(alpha[arc.nextstate], this_alpha + arc_like);
+    }
+    Weight f = lat.Final(s);
+    if (f != Weight::Zero()) {
+      double final_like = this_alpha - (f.Value1() + f.Value2());
+      tot_forward_prob = LogAdd(tot_forward_prob, final_like);
+      KALDI_ASSERT(state_times[s] == max_time &&
+                   "Lattice is inconsistent (final-prob not at max_time)");
+    }
+  }
+  // First Pass Backward,
+  for (StateId s = num_states-1; s >= 0; s--) {
+    Weight f = lat.Final(s);
+    double this_beta = -(f.Value1() + f.Value2());
+    for (ArcIterator<Lattice> aiter(lat, s); !aiter.Done(); aiter.Next()) {
+      const Arc &arc = aiter.Value();
+      double arc_like = -ConvertToCost(arc.weight),
+          arc_beta = beta[arc.nextstate] + arc_like;
+      this_beta = LogAdd(this_beta, arc_beta);
+    }
+    beta[s] = this_beta;
+  }
+  // First Pass Forward-Backward Check
+  double tot_backward_prob = beta[0];
+  // may loose the condition somehow here 1e-6 (was 1e-8)
+  if (!ApproxEqual(tot_forward_prob, tot_backward_prob, 1e-6)) {
+    KALDI_ERR << "Total forward probability over lattice = " << tot_forward_prob
+              << ", while total backward probability = " << tot_backward_prob;
+  }
+
+  alpha_smbr[0] = 0.0;
+  // Second Pass Forward, calculate forward for MPFE/SMBR
+  for (StateId s = 0; s < num_states; s++) {
+    double this_alpha = alpha[s];
+    for (ArcIterator<Lattice> aiter(lat, s); !aiter.Done(); aiter.Next()) {
+      const Arc &arc = aiter.Value();
+      double arc_like = -ConvertToCost(arc.weight);
+      double frame_acc = 0.0;
+      if (arc.ilabel != 0) {
+        int32 cur_time = state_times[s];
+        int32 phone = trans.TransitionIdToPhone(arc.ilabel),
+            ref_phone = trans.TransitionIdToPhone(num_ali[cur_time]);
+        bool phone_is_sil = std::binary_search(silence_phones.begin(),
+                                               silence_phones.end(),
+                                               phone),
+            ref_phone_is_sil = std::binary_search(silence_phones.begin(),
+                                                  silence_phones.end(),
+                                                  ref_phone),
+            both_sil = phone_is_sil && ref_phone_is_sil;
+        if (!is_mpfe) { // smbr.
+          int32 pdf = trans.TransitionIdToPdf(arc.ilabel),
+              ref_pdf = trans.TransitionIdToPdf(num_ali[cur_time]);
+          if (!one_silence_class)  // old behavior
+            frame_acc = (pdf == ref_pdf && !phone_is_sil) ? 1.0 : 0.0;
+          else
+            frame_acc = (pdf == ref_pdf || both_sil) ? 1.0 : 0.0;
+        } else {
+          if (!one_silence_class)  // old behavior
+            frame_acc = (phone == ref_phone && !phone_is_sil) ? 1.0 : 0.0;
+          else
+            frame_acc = (phone == ref_phone || both_sil) ? 1.0 : 0.0;
+        }
+      }
+      double arc_scale = Exp(alpha[s] + arc_like - alpha[arc.nextstate]);
+      alpha_smbr[arc.nextstate] += arc_scale * (alpha_smbr[s] + frame_acc);
+    }
+    Weight f = lat.Final(s);
+    if (f != Weight::Zero()) {
+      double final_like = this_alpha - (f.Value1() + f.Value2());
+      double arc_scale = Exp(final_like - tot_forward_prob);
+      tot_forward_score += arc_scale * alpha_smbr[s];
+      KALDI_ASSERT(state_times[s] == max_time &&
+                   "Lattice is inconsistent (final-prob not at max_time)");
+    }
+  }
+  // Second Pass Backward, collect Mpe style posteriors
+  for (StateId s = num_states-1; s >= 0; s--) {
+    for (ArcIterator<Lattice> aiter(lat, s); !aiter.Done(); aiter.Next()) {
+      const Arc &arc = aiter.Value();
+      double arc_like = -ConvertToCost(arc.weight),
+          arc_beta = beta[arc.nextstate] + arc_like;
+      double frame_acc = 0.0;
+      int32 transition_id = arc.ilabel;
+      if (arc.ilabel != 0) {
+        int32 cur_time = state_times[s];
+        int32 phone = trans.TransitionIdToPhone(arc.ilabel),
+            ref_phone = trans.TransitionIdToPhone(num_ali[cur_time]);
+        bool phone_is_sil = std::binary_search(silence_phones.begin(),
+                                               silence_phones.end(), phone),
+            ref_phone_is_sil = std::binary_search(silence_phones.begin(),
+                                                  silence_phones.end(),
+                                                  ref_phone),
+            both_sil = phone_is_sil && ref_phone_is_sil;
+        if (!is_mpfe) { // smbr.
+          int32 pdf = trans.TransitionIdToPdf(arc.ilabel),
+              ref_pdf = trans.TransitionIdToPdf(num_ali[cur_time]);
+          if (!one_silence_class)  // old behavior
+            frame_acc = (pdf == ref_pdf && !phone_is_sil) ? 1.0 : 0.0;
+          else
+            frame_acc = (pdf == ref_pdf || both_sil) ? 1.0 : 0.0;
+        } else {
+          if (!one_silence_class)  // old behavior
+            frame_acc = (phone == ref_phone && !phone_is_sil) ? 1.0 : 0.0;
+          else
+            frame_acc = (phone == ref_phone || both_sil) ? 1.0 : 0.0;
+        }
+      }
+      double arc_scale = Exp(beta[arc.nextstate] + arc_like - beta[s]);
+      // check arc_scale NAN,
+      // this is to prevent partial paths in Lattices
+      // i.e., paths don't survive to the final state
+      if (KALDI_ISNAN(arc_scale)) arc_scale = 0;
+      beta_smbr[s] += arc_scale * (beta_smbr[arc.nextstate] + frame_acc);
+
+      if (transition_id != 0) { // Arc has a transition-id on it [not epsilon]
+        double posterior = Exp(alpha[s] + arc_beta - tot_forward_prob);
+        double acc_diff = alpha_smbr[s] + frame_acc + beta_smbr[arc.nextstate]
+                               - tot_forward_score;
+        double posterior_smbr = posterior * acc_diff;
+        (*post)[state_times[s]].push_back(std::make_pair(transition_id,
+                                                         static_cast<BaseFloat>(posterior_smbr)));
+      }
+    }
+  }
+
+  //Second Pass Forward Backward check
+  double tot_backward_score = beta_smbr[0];  // Initial state id == 0
+  // may loose the condition somehow here 1e-5/1e-4
+  if (!ApproxEqual(tot_forward_score, tot_backward_score, 1e-4)) {
+    KALDI_ERR << "Total forward score over lattice = " << tot_forward_score
+              << ", while total backward score = " << tot_backward_score;
+  }
+
+  // Output the computed posteriors
+  for (int32 t = 0; t < max_time; t++)
+    MergePairVectorSumming(&((*post)[t]));
+  return tot_forward_score;
+}
+
+
+
+BaseFloat LatticeForwardBackwardMpeVariantsCctc(
+    const ctc::CctcTransitionModel &trans,
+    const std::vector<int32> &silence_phones,
+    const Lattice &lat,
+    const std::vector<int32> &num_ali,
+    std::string criterion,
+    bool one_silence_class,
+    Posterior *post) {
+  using namespace fst;
+  typedef Lattice::Arc Arc;
+  typedef Arc::Weight Weight;
+  typedef Arc::StateId StateId;
+
+  KALDI_ASSERT(criterion == "mpfe" || criterion == "smbr");
+  bool is_mpfe = (criterion == "mpfe");
+
+  if (lat.Properties(fst::kTopSorted, true) == 0)
+    KALDI_ERR << "Input lattice must be topologically sorted.";
+  KALDI_ASSERT(lat.Start() == 0);
+
+  int32 num_states = lat.NumStates();
+  vector<int32> state_times;
+  int32 max_time = LatticeStateTimes(lat, &state_times);
+  KALDI_ASSERT(max_time == static_cast<int32>(num_ali.size()));
+  std::vector<double> alpha(num_states, kLogZeroDouble),
+      alpha_smbr(num_states, 0), //forward variable for sMBR
+      beta(num_states, kLogZeroDouble),
+      beta_smbr(num_states, 0); //backward variable for sMBR
+
+  double tot_forward_prob = kLogZeroDouble;
+  double tot_forward_score = 0;
+
+  post->clear();
+  post->resize(max_time);
+
+  alpha[0] = 0.0;
+  // First Pass Forward,
+  for (StateId s = 0; s < num_states; s++) {
+    double this_alpha = alpha[s];
+    for (ArcIterator<Lattice> aiter(lat, s); !aiter.Done(); aiter.Next()) {
+      const Arc &arc = aiter.Value();
+      double arc_like = -ConvertToCost(arc.weight);
+      alpha[arc.nextstate] = LogAdd(alpha[arc.nextstate], this_alpha + arc_like);
+    }
+    Weight f = lat.Final(s);
+    if (f != Weight::Zero()) {
+      double final_like = this_alpha - (f.Value1() + f.Value2());
+      tot_forward_prob = LogAdd(tot_forward_prob, final_like);
+      KALDI_ASSERT(state_times[s] == max_time &&
+                   "Lattice is inconsistent (final-prob not at max_time)");
+    }
+  }
+  // First Pass Backward,
+  for (StateId s = num_states-1; s >= 0; s--) {
+    Weight f = lat.Final(s);
+    double this_beta = -(f.Value1() + f.Value2());
+    for (ArcIterator<Lattice> aiter(lat, s); !aiter.Done(); aiter.Next()) {
+      const Arc &arc = aiter.Value();
+      double arc_like = -ConvertToCost(arc.weight),
+          arc_beta = beta[arc.nextstate] + arc_like;
+      this_beta = LogAdd(this_beta, arc_beta);
+    }
+    beta[s] = this_beta;
+  }
+  // First Pass Forward-Backward Check
+  double tot_backward_prob = beta[0];
+  // may loose the condition somehow here 1e-6 (was 1e-8)
+  if (!ApproxEqual(tot_forward_prob, tot_backward_prob, 1e-6)) {
+    KALDI_ERR << "Total forward probability over lattice = " << tot_forward_prob
+              << ", while total backward probability = " << tot_backward_prob;
+  }
+
+  alpha_smbr[0] = 0.0;
+  // Second Pass Forward, calculate forward for MPFE/SMBR
+  for (StateId s = 0; s < num_states; s++) {
+    double this_alpha = alpha[s];
+    for (ArcIterator<Lattice> aiter(lat, s); !aiter.Done(); aiter.Next()) {
+      const Arc &arc = aiter.Value();
+      double arc_like = -ConvertToCost(arc.weight);
+      double frame_acc = 0.0;
+      if (arc.ilabel != 0) {
+        int32 cur_time = state_times[s];
+        int32 phone = trans.GraphLabelToPhone(arc.ilabel),
+            ref_phone = trans.GraphLabelToPhone(num_ali[cur_time]);
+        bool phone_is_sil = std::binary_search(silence_phones.begin(),
+                                               silence_phones.end(),
+                                               phone),
+            ref_phone_is_sil = std::binary_search(silence_phones.begin(),
+                                                  silence_phones.end(),
+                                                  ref_phone),
+            both_sil = phone_is_sil && ref_phone_is_sil;
+        if (!is_mpfe) { // smbr.
+          int32 pdf = trans.GraphLabelToOutputIndex(arc.ilabel),
+              ref_pdf = trans.GraphLabelToOutputIndex(num_ali[cur_time]);
+          if (!one_silence_class)  // old behavior
+            frame_acc = (pdf == ref_pdf && !phone_is_sil) ? 1.0 : 0.0;
+          else
+            frame_acc = (pdf == ref_pdf || both_sil) ? 1.0 : 0.0;
+        } else {
+          if (!one_silence_class)  // old behavior
+            frame_acc = (phone == ref_phone && !phone_is_sil) ? 1.0 : 0.0;
+          else
+            frame_acc = (phone == ref_phone || both_sil) ? 1.0 : 0.0;
+        }
+      }
+      double arc_scale = Exp(alpha[s] + arc_like - alpha[arc.nextstate]);
+      alpha_smbr[arc.nextstate] += arc_scale * (alpha_smbr[s] + frame_acc);
+    }
+    Weight f = lat.Final(s);
+    if (f != Weight::Zero()) {
+      double final_like = this_alpha - (f.Value1() + f.Value2());
+      double arc_scale = Exp(final_like - tot_forward_prob);
+      tot_forward_score += arc_scale * alpha_smbr[s];
+      KALDI_ASSERT(state_times[s] == max_time &&
+                   "Lattice is inconsistent (final-prob not at max_time)");
+    }
+  }
+  // Second Pass Backward, collect Mpe style posteriors
+  for (StateId s = num_states-1; s >= 0; s--) {
+    for (ArcIterator<Lattice> aiter(lat, s); !aiter.Done(); aiter.Next()) {
+      const Arc &arc = aiter.Value();
+      double arc_like = -ConvertToCost(arc.weight),
+          arc_beta = beta[arc.nextstate] + arc_like;
+      double frame_acc = 0.0;
+      int32 transition_id = arc.ilabel;
+      if (arc.ilabel != 0) {
+        int32 cur_time = state_times[s];
+        int32 phone = trans.GraphLabelToPhone(arc.ilabel),
+            ref_phone = trans.GraphLabelToPhone(num_ali[cur_time]);
+        bool phone_is_sil = std::binary_search(silence_phones.begin(),
+                                               silence_phones.end(), phone),
+            ref_phone_is_sil = std::binary_search(silence_phones.begin(),
+                                                  silence_phones.end(),
+                                                  ref_phone),
+            both_sil = phone_is_sil && ref_phone_is_sil;
+        if (!is_mpfe) { // smbr.
+          int32 pdf = trans.GraphLabelToOutputIndex(arc.ilabel),
+              ref_pdf = trans.GraphLabelToOutputIndex(num_ali[cur_time]);
+          if (!one_silence_class)  // old behavior
+            frame_acc = (pdf == ref_pdf && !phone_is_sil) ? 1.0 : 0.0;
+          else
+            frame_acc = (pdf == ref_pdf || both_sil) ? 1.0 : 0.0;
+        } else {
+          if (!one_silence_class)  // old behavior
+            frame_acc = (phone == ref_phone && !phone_is_sil) ? 1.0 : 0.0;
+          else
+            frame_acc = (phone == ref_phone || both_sil) ? 1.0 : 0.0;
+        }
+      }
+      double arc_scale = Exp(beta[arc.nextstate] + arc_like - beta[s]);
+      // check arc_scale NAN,
+      // this is to prevent partial paths in Lattices
+      // i.e., paths don't survive to the final state
+      if (KALDI_ISNAN(arc_scale)) arc_scale = 0;
+      beta_smbr[s] += arc_scale * (beta_smbr[arc.nextstate] + frame_acc);
+
+      if (transition_id != 0) { // Arc has a transition-id on it [not epsilon]
+        double posterior = Exp(alpha[s] + arc_beta - tot_forward_prob);
+        double acc_diff = alpha_smbr[s] + frame_acc + beta_smbr[arc.nextstate]
+                               - tot_forward_score;
+        double posterior_smbr = posterior * acc_diff;
+        (*post)[state_times[s]].push_back(std::make_pair(transition_id,
+                                                         static_cast<BaseFloat>(posterior_smbr)));
+      }
+    }
+  }
+
+  //Second Pass Forward Backward check
+  double tot_backward_score = beta_smbr[0];  // Initial state id == 0
+  // may loose the condition somehow here 1e-5/1e-4
+  if (!ApproxEqual(tot_forward_score, tot_backward_score, 1e-4)) {
+    KALDI_ERR << "Total forward score over lattice = " << tot_forward_score
+              << ", while total backward score = " << tot_backward_score;
+  }
+
+  // Output the computed posteriors
+  for (int32 t = 0; t < max_time; t++)
+    MergePairVectorSumming(&((*post)[t]));
+  return tot_forward_score;
+}
+
+bool CompactLatticeToWordAlignment(const CompactLattice &clat,
+                                   std::vector<int32> *words,
+                                   std::vector<int32> *begin_times,
+                                   std::vector<int32> *lengths) {
+  words->clear();
+  begin_times->clear();
+  lengths->clear();
+  typedef CompactLattice::Arc Arc;
+  typedef Arc::Label Label;
+  typedef CompactLattice::StateId StateId;
+  typedef CompactLattice::Weight Weight;
+  using namespace fst;
+  StateId state = clat.Start();
+  int32 cur_time = 0;
+  if (state == kNoStateId) {
+    KALDI_WARN << "Empty lattice.";
+    return false;
+  }
+  while (1) {
+    Weight final = clat.Final(state);
+    size_t num_arcs = clat.NumArcs(state);
+    if (final != Weight::Zero()) {
+      if (num_arcs != 0) {
+        KALDI_WARN << "Lattice is not linear.";
+        return false;
+      }
+      if (! final.String().empty()) {
+        KALDI_WARN << "Lattice has alignments on final-weight: probably "
+            "was not word-aligned (alignments will be approximate)";
+      }
+      return true;
+    } else {
+      if (num_arcs != 1) {
+        KALDI_WARN << "Lattice is not linear: num-arcs = " << num_arcs;
+        return false;
+      }
+      fst::ArcIterator<CompactLattice> aiter(clat, state);
+      const Arc &arc = aiter.Value();
+      Label word_id = arc.ilabel; // Note: ilabel==olabel, since acceptor.
+      // Also note: word_id may be zero; we output it anyway.
+      int32 length = arc.weight.String().size();
+      words->push_back(word_id);
+      begin_times->push_back(cur_time);
+      lengths->push_back(length);
+      cur_time += length;
+      state = arc.nextstate;
+    }
+  }
+}
+
+
+bool CompactLatticeToWordProns(
+    const TransitionModel &tmodel,
+    const CompactLattice &clat,
+    std::vector<int32> *words,
+    std::vector<int32> *begin_times,
+    std::vector<int32> *lengths,
+    std::vector<std::vector<int32> > *prons,
+    std::vector<std::vector<int32> > *phone_lengths) {
+  words->clear();
+  begin_times->clear();
+  lengths->clear();
+  prons->clear();
+  phone_lengths->clear();
+  typedef CompactLattice::Arc Arc;
+  typedef Arc::Label Label;
+  typedef CompactLattice::StateId StateId;
+  typedef CompactLattice::Weight Weight;
+  using namespace fst;
+  StateId state = clat.Start();
+  int32 cur_time = 0;
+  if (state == kNoStateId) {
+    KALDI_WARN << "Empty lattice.";
+    return false;
+  }
+  while (1) {
+    Weight final = clat.Final(state);
+    size_t num_arcs = clat.NumArcs(state);
+    if (final != Weight::Zero()) {
+      if (num_arcs != 0) {
+        KALDI_WARN << "Lattice is not linear.";
+        return false;
+      }
+      if (! final.String().empty()) {
+        KALDI_WARN << "Lattice has alignments on final-weight: probably "
+            "was not word-aligned (alignments will be approximate)";
+      }
+      return true;
+    } else {
+      if (num_arcs != 1) {
+        KALDI_WARN << "Lattice is not linear: num-arcs = " << num_arcs;
+        return false;
+      }
+      fst::ArcIterator<CompactLattice> aiter(clat, state);
+      const Arc &arc = aiter.Value();
+      Label word_id = arc.ilabel; // Note: ilabel==olabel, since acceptor.
+      // Also note: word_id may be zero; we output it anyway.
+      int32 length = arc.weight.String().size();
+      words->push_back(word_id);
+      begin_times->push_back(cur_time);
+      lengths->push_back(length);
+      const std::vector<int32> &arc_alignment = arc.weight.String();
+      std::vector<std::vector<int32> > split_alignment;
+      SplitToPhones(tmodel, arc_alignment, &split_alignment);
+      std::vector<int32> phones(split_alignment.size());
+      std::vector<int32> plengths(split_alignment.size());
+      for (size_t i = 0; i < split_alignment.size(); i++) {
+        KALDI_ASSERT(!split_alignment[i].empty());
+        phones[i] = tmodel.TransitionIdToPhone(split_alignment[i][0]);
+        plengths[i] = split_alignment[i].size();
+      }
+      prons->push_back(phones);
+      phone_lengths->push_back(plengths);
+
+      cur_time += length;
+      state = arc.nextstate;
+    }
+  }
+}
+
+
+
+void CompactLatticeShortestPath(const CompactLattice &clat,
+                                CompactLattice *shortest_path) {
+  using namespace fst;
+  if (clat.Properties(fst::kTopSorted, true) == 0) {
+    CompactLattice clat_copy(clat);
+    if (!TopSort(&clat_copy))
+      KALDI_ERR << "Was not able to topologically sort lattice (cycles found?)";
+    CompactLatticeShortestPath(clat_copy, shortest_path);
+    return;
+  }
+  // Now we can assume it's topologically sorted.
+  shortest_path->DeleteStates();
+  if (clat.Start() == kNoStateId) return;
+  KALDI_ASSERT(clat.Start() == 0); // since top-sorted.
+  typedef CompactLatticeArc Arc;
+  typedef Arc::StateId StateId;
+  typedef CompactLatticeWeight Weight;
+  vector<std::pair<double, StateId> > best_cost_and_pred(clat.NumStates() + 1);
+  StateId superfinal = clat.NumStates();
+  for (StateId s = 0; s <= clat.NumStates(); s++) {
+    best_cost_and_pred[s].first = numeric_limits<double>::infinity();
+    best_cost_and_pred[s].second = fst::kNoStateId;
+  }
+  best_cost_and_pred[0].first = 0;
+  for (StateId s = 0; s < clat.NumStates(); s++) {
+    double my_cost = best_cost_and_pred[s].first;
+    for (ArcIterator<CompactLattice> aiter(clat, s);
+         !aiter.Done();
+         aiter.Next()) {
+      const Arc &arc = aiter.Value();
+      double arc_cost = ConvertToCost(arc.weight),
+          next_cost = my_cost + arc_cost;
+      if (next_cost < best_cost_and_pred[arc.nextstate].first) {
+        best_cost_and_pred[arc.nextstate].first = next_cost;
+        best_cost_and_pred[arc.nextstate].second = s;
+      }
+    }
+    double final_cost = ConvertToCost(clat.Final(s)),
+        tot_final = my_cost + final_cost;
+    if (tot_final < best_cost_and_pred[superfinal].first) {
+      best_cost_and_pred[superfinal].first = tot_final;
+      best_cost_and_pred[superfinal].second = s;
+    }
+  }
+  std::vector<StateId> states; // states on best path.
+  StateId cur_state = superfinal;
+  while (cur_state != 0) {
+    StateId prev_state = best_cost_and_pred[cur_state].second;
+    if (prev_state == kNoStateId) {
+      KALDI_WARN << "Failure in best-path algorithm for lattice (infinite costs?)";
+      return; // return empty best-path.
+    }
+    states.push_back(prev_state);
+    KALDI_ASSERT(cur_state != prev_state && "Lattice with cycles");
+    cur_state = prev_state;
+  }
+  std::reverse(states.begin(), states.end());
+  for (size_t i = 0; i < states.size(); i++)
+    shortest_path->AddState();
+  for (StateId s = 0; static_cast<size_t>(s) < states.size(); s++) {
+    if (s == 0) shortest_path->SetStart(s);
+    if (static_cast<size_t>(s + 1) < states.size()) { // transition to next state.
+      bool have_arc = false;
+      Arc cur_arc;
+      for (ArcIterator<CompactLattice> aiter(clat, states[s]);
+           !aiter.Done();
+           aiter.Next()) {
+        const Arc &arc = aiter.Value();
+        if (arc.nextstate == states[s+1]) {
+          if (!have_arc ||
+              ConvertToCost(arc.weight) < ConvertToCost(cur_arc.weight)) {
+            cur_arc = arc;
+            have_arc = true;
+          }
+        }
+      }
+      KALDI_ASSERT(have_arc && "Code error.");
+      shortest_path->AddArc(s, Arc(cur_arc.ilabel, cur_arc.olabel,
+                                   cur_arc.weight, s+1));
+    } else { // final-prob.
+      shortest_path->SetFinal(s, clat.Final(states[s]));
+    }
+  }
+}
+
+void AddWordInsPenToCompactLattice(BaseFloat word_ins_penalty,
+                                   CompactLattice *clat) {
+  typedef CompactLatticeArc Arc;
+  int32 num_states = clat->NumStates();
+
+  //scan the lattice
+  for (int32 state = 0; state < num_states; state++) {
+    for (fst::MutableArcIterator<CompactLattice> aiter(clat, state);
+         !aiter.Done(); aiter.Next()) {
+
+      Arc arc(aiter.Value());
+
+      if (arc.ilabel != 0) { // if there is a word on this arc
+        LatticeWeight weight = arc.weight.Weight();
+        // add word insertion penalty to lattice
+        weight.SetValue1( weight.Value1() + word_ins_penalty);
+        arc.weight.SetWeight(weight);
+        aiter.SetValue(arc);
+      }
+    } // end looping over arcs
+  }  // end looping over states
+}
+
+struct ClatRescoreTuple {
+  ClatRescoreTuple(int32 state, int32 arc, int32 tid):
+      state_id(state), arc_id(arc), tid(tid) { }
+  int32 state_id;
+  int32 arc_id;
+  int32 tid;
+};
+
+/** RescoreCompactLatticeInternal is the internal code for both
+    RescoreCompactLattice and RescoreCompatLatticeSpeedup.  For
+    RescoreCompactLattice, "tmodel" will be NULL and speedup_factor will be 1.0.
+ */
+bool RescoreCompactLatticeInternal(
+    const TransitionModel *tmodel,
+    BaseFloat speedup_factor,
+    DecodableInterface *decodable,
+    CompactLattice *clat) {
+  KALDI_ASSERT(speedup_factor >= 1.0);
+  if (clat->NumStates() == 0) {
+    KALDI_WARN << "Rescoring empty lattice";
+    return false;
+  }
+  if (!clat->Properties(fst::kTopSorted, true)) {
+    if (fst::TopSort(clat) == false) {
+      KALDI_WARN << "Cycles detected in lattice.";
+      return false;
+    }
+  }
+  std::vector<int32> state_times;
+  int32 utt_len = CompactLatticeStateTimes(*clat, &state_times);
+
+  std::vector<std::vector<ClatRescoreTuple> > time_to_state(utt_len);
+
+  int32 num_states = clat->NumStates();
+  KALDI_ASSERT(num_states == state_times.size());
+  for (size_t state = 0; state < num_states; state++) {
+    KALDI_ASSERT(state_times[state] >= 0);
+    int32 t = state_times[state];
+    int32 arc_id = 0;
+    for (fst::MutableArcIterator<CompactLattice> aiter(clat, state);
+         !aiter.Done(); aiter.Next(), arc_id++) {
+      CompactLatticeArc arc = aiter.Value();
+      std::vector<int32> arc_string = arc.weight.String();
+
+      for (size_t offset = 0; offset < arc_string.size(); offset++) {
+        if (t < utt_len) { // end state may be past this..
+          int32 tid = arc_string[offset];
+          time_to_state[t+offset].push_back(ClatRescoreTuple(state, arc_id, tid));
+        } else {
+          if (t != utt_len) {
+            KALDI_WARN << "There appears to be lattice/feature mismatch, "
+                       << "aborting.";
+            return false;
+          }
+        }
+      }
+    }
+    if (clat->Final(state) != CompactLatticeWeight::Zero()) {
+      arc_id = -1;
+      std::vector<int32> arc_string = clat->Final(state).String();
+      for (size_t offset = 0; offset < arc_string.size(); offset++) {
+        KALDI_ASSERT(t + offset < utt_len); // already checked in
+        // CompactLatticeStateTimes, so would be code error.
+        time_to_state[t+offset].push_back(
+            ClatRescoreTuple(state, arc_id, arc_string[offset]));
+      }
+    }
+  }
+
+  for (int32 t = 0; t < utt_len; t++) {
+    if ((t < utt_len - 1) && decodable->IsLastFrame(t)) {
+      KALDI_WARN << "Features are too short for lattice: utt-len is "
+                 << utt_len << ", " << t << " is last frame";
+      return false;
+    }
+    // frame_scale is the scale we put on the computed acoustic probs for this
+    // frame.  It will always be 1.0 if tmodel == NULL (i.e. if we are not doing
+    // the "speedup" code).  For frames with multiple pdf-ids it will be one.
+    // For frames with only one pdf-id, it will equal speedup_factor (>=1.0)
+    // with probability 1.0 / speedup_factor, and zero otherwise.  If it is zero,
+    // we can avoid computing the probabilities.
+    BaseFloat frame_scale = 1.0;
+    KALDI_ASSERT(!time_to_state[t].empty());
+    if (tmodel != NULL) {
+      int32 pdf_id = tmodel->TransitionIdToPdf(time_to_state[t][0].tid);
+      bool frame_has_multiple_pdfs = false;
+      for (size_t i = 1; i < time_to_state[t].size(); i++) {
+        if (tmodel->TransitionIdToPdf(time_to_state[t][i].tid) != pdf_id) {
+          frame_has_multiple_pdfs = true;
+          break;
+        }
+      }
+      if (frame_has_multiple_pdfs) {
+        frame_scale = 1.0;
+      } else {
+        if (WithProb(1.0 / speedup_factor)) {
+          frame_scale = speedup_factor;
+        } else {
+          frame_scale = 0.0;
+        }
+      }
+      if (frame_scale == 0.0)
+        continue; // the code below would be pointless.
+    }
+
+    for (size_t i = 0; i < time_to_state[t].size(); i++) {
+      int32 state = time_to_state[t][i].state_id;
+      int32 arc_id = time_to_state[t][i].arc_id;
+      int32 tid = time_to_state[t][i].tid;
+
+      if (arc_id == -1) { // Final state
+        // Access the trans_id
+        CompactLatticeWeight curr_clat_weight = clat->Final(state);
+
+        // Calculate likelihood
+        BaseFloat log_like = decodable->LogLikelihood(t, tid) * frame_scale;
+        // update weight
+        CompactLatticeWeight new_clat_weight = curr_clat_weight;
+        LatticeWeight new_lat_weight = new_clat_weight.Weight();
+        new_lat_weight.SetValue2(-log_like + curr_clat_weight.Weight().Value2());
+        new_clat_weight.SetWeight(new_lat_weight);
+        clat->SetFinal(state, new_clat_weight);
+      } else {
+        fst::MutableArcIterator<CompactLattice> aiter(clat, state);
+
+        aiter.Seek(arc_id);
+        CompactLatticeArc arc = aiter.Value();
+
+        // Calculate likelihood
+        BaseFloat log_like = decodable->LogLikelihood(t, tid) * frame_scale;
+        // update weight
+        LatticeWeight new_weight = arc.weight.Weight();
+        new_weight.SetValue2(-log_like + arc.weight.Weight().Value2());
+        arc.weight.SetWeight(new_weight);
+        aiter.SetValue(arc);
+      }
+    }
+  }
+  return true;
+}
+
+
+bool RescoreCompactLatticeSpeedup(
+    const TransitionModel &tmodel,
+    BaseFloat speedup_factor,
+    DecodableInterface *decodable,
+    CompactLattice *clat) {
+  return RescoreCompactLatticeInternal(&tmodel, speedup_factor, decodable, clat);
+}
+
+bool RescoreCompactLattice(DecodableInterface *decodable,
+                           CompactLattice *clat) {
+  return RescoreCompactLatticeInternal(NULL, 1.0, decodable, clat);
+}
+
+
+bool RescoreLattice(DecodableInterface *decodable,
+                    Lattice *lat) {
+  if (lat->NumStates() == 0) {
+    KALDI_WARN << "Rescoring empty lattice";
+    return false;
+  }
+  if (!lat->Properties(fst::kTopSorted, true)) {
+    if (fst::TopSort(lat) == false) {
+      KALDI_WARN << "Cycles detected in lattice.";
+      return false;
+    }
+  }
+  std::vector<int32> state_times;
+  int32 utt_len = LatticeStateTimes(*lat, &state_times);
+
+  std::vector<std::vector<int32> > time_to_state(utt_len );
+
+  int32 num_states = lat->NumStates();
+  KALDI_ASSERT(num_states == state_times.size());
+  for (size_t state = 0; state < num_states; state++) {
+    int32 t = state_times[state];
+    // Don't check t >= 0 because non-accessible states could have t = -1.
+    KALDI_ASSERT(t <= utt_len);
+    if (t >= 0 && t < utt_len)
+      time_to_state[t].push_back(state);
+  }
+
+  for (int32 t = 0; t < utt_len; t++) {
+    if ((t < utt_len - 1) && decodable->IsLastFrame(t)) {
+      KALDI_WARN << "Features are too short for lattice: utt-len is "
+                 << utt_len << ", " << t << " is last frame";
+      return false;
+    }
+    for (size_t i = 0; i < time_to_state[t].size(); i++) {
+      int32 state = time_to_state[t][i];
+      for (fst::MutableArcIterator<Lattice> aiter(lat, state);
+           !aiter.Done(); aiter.Next()) {
+        LatticeArc arc = aiter.Value();
+        if (arc.ilabel != 0) {
+          int32 trans_id = arc.ilabel; // Note: it doesn't necessarily
+          // have to be a transition-id, just whatever the Decodable
+          // object is expecting, but it's normally a transition-id.
+
+          BaseFloat log_like = decodable->LogLikelihood(t, trans_id);
+          arc.weight.SetValue2(-log_like + arc.weight.Value2());
+          aiter.SetValue(arc);
+        }
+      }
+    }
+  }
+  return true;
+}
+
+
+BaseFloat LatticeForwardBackwardMmi(
+    const TransitionModel &tmodel,
+    const Lattice &lat,
+    const std::vector<int32> &num_ali,
+    bool drop_frames,
+    bool convert_to_pdf_ids,
+    bool cancel,
+    Posterior *post) {
+  // First compute the MMI posteriors.
+
+  Posterior den_post;
+  BaseFloat ans = LatticeForwardBackward(lat,
+                                         &den_post,
+                                         NULL);
+
+  Posterior num_post;
+  AlignmentToPosterior(num_ali, &num_post);
+
+  // Now negate the MMI posteriors and add the numerator
+  // posteriors.
+  ScalePosterior(-1.0, &den_post);
+
+  if (convert_to_pdf_ids) {
+    Posterior num_tmp;
+    ConvertPosteriorToPdfs(tmodel, num_post, &num_tmp);
+    num_tmp.swap(num_post);
+    Posterior den_tmp;
+    ConvertPosteriorToPdfs(tmodel, den_post, &den_tmp);
+    den_tmp.swap(den_post);
+  }
+
+  MergePosteriors(num_post, den_post,
+                  cancel, drop_frames, post);
+
+  return ans;
+}
+
+
+BaseFloat LatticeForwardBackwardMmiCctc(
+    const ctc::CctcTransitionModel &tmodel,
+    const Lattice &lat,
+    const std::vector<int32> &num_ali,
+    bool drop_frames,
+    bool convert_to_pdf_ids,
+    bool cancel,
+    Posterior *post) {
+  // First compute the MMI posteriors.
+
+  Posterior den_post;
+  BaseFloat ans = LatticeForwardBackward(lat,
+                                         &den_post,
+                                         NULL);
+
+  Posterior num_post;
+  AlignmentToPosterior(num_ali, &num_post);
+
+  // Now negate the MMI posteriors and add the numerator
+  // posteriors.
+  ScalePosterior(-1.0, &den_post);
+
+  if (convert_to_pdf_ids) {
+    Posterior num_tmp;
+    ConvertPosteriorToPdfsCctc(tmodel, num_post, &num_tmp);
+    num_tmp.swap(num_post);
+    Posterior den_tmp;
+    ConvertPosteriorToPdfsCctc(tmodel, den_post, &den_tmp);
+    den_tmp.swap(den_post);
+  }
+
+  MergePosteriors(num_post, den_post,
+                  cancel, drop_frames, post);
+
+  return ans;
+}
+
+
+int32 LongestSentenceLength(const Lattice &lat) {
+  typedef Lattice::Arc Arc;
+  typedef Arc::Label Label;
+  typedef Arc::StateId StateId;
+
+  if (lat.Properties(fst::kTopSorted, true) == 0) {
+    Lattice lat_copy(lat);
+    if (!TopSort(&lat_copy))
+      KALDI_ERR << "Was not able to topologically sort lattice (cycles found?)";
+    return LongestSentenceLength(lat_copy);
+  }
+  std::vector<int32> max_length(lat.NumStates(), 0);
+  int32 lattice_max_length = 0;
+  for (StateId s = 0; s < lat.NumStates(); s++) {
+    int32 this_max_length = max_length[s];
+    for (fst::ArcIterator<Lattice> aiter(lat, s); !aiter.Done(); aiter.Next()) {
+      const Arc &arc = aiter.Value();
+      bool arc_has_word = (arc.olabel != 0);
+      StateId nextstate = arc.nextstate;
+      KALDI_ASSERT(static_cast<size_t>(nextstate) < max_length.size());
+      if (arc_has_word) {
+        // A lattice should ideally not have cycles anyway; a cycle with a word
+        // on is something very bad.
+        KALDI_ASSERT(nextstate > s && "Lattice has cycles with words on.");
+        max_length[nextstate] = std::max(max_length[nextstate],
+                                         this_max_length + 1);
+      } else {
+        max_length[nextstate] = std::max(max_length[nextstate],
+                                         this_max_length);
+      }
+    }
+    if (lat.Final(s) != LatticeWeight::Zero())
+      lattice_max_length = std::max(lattice_max_length, max_length[s]);
+  }
+  return lattice_max_length;
+}
+
+int32 LongestSentenceLength(const CompactLattice &clat) {
+  typedef CompactLattice::Arc Arc;
+  typedef Arc::Label Label;
+  typedef Arc::StateId StateId;
+
+  if (clat.Properties(fst::kTopSorted, true) == 0) {
+    CompactLattice clat_copy(clat);
+    if (!TopSort(&clat_copy))
+      KALDI_ERR << "Was not able to topologically sort lattice (cycles found?)";
+    return LongestSentenceLength(clat_copy);
+  }
+  std::vector<int32> max_length(clat.NumStates(), 0);
+  int32 lattice_max_length = 0;
+  for (StateId s = 0; s < clat.NumStates(); s++) {
+    int32 this_max_length = max_length[s];
+    for (fst::ArcIterator<CompactLattice> aiter(clat, s);
+         !aiter.Done(); aiter.Next()) {
+      const Arc &arc = aiter.Value();
+      bool arc_has_word = (arc.ilabel != 0); // note: olabel == ilabel.
+      // also note: for normal CompactLattice, e.g. as produced by
+      // determinization, all arcs will have nonzero labels, but the user might
+      // decide to remplace some of the labels with zero for some reason, and we
+      // want to support this.
+      StateId nextstate = arc.nextstate;
+      KALDI_ASSERT(static_cast<size_t>(nextstate) < max_length.size());
+      KALDI_ASSERT(nextstate > s && "CompactLattice has cycles");
+      if (arc_has_word)
+        max_length[nextstate] = std::max(max_length[nextstate],
+                                         this_max_length + 1);
+      else
+        max_length[nextstate] = std::max(max_length[nextstate],
+                                         this_max_length);
+    }
+    if (clat.Final(s) != CompactLatticeWeight::Zero())
+      lattice_max_length = std::max(lattice_max_length, max_length[s]);
+  }
+  return lattice_max_length;
+}
+
+void ComposeCompactLatticeDeterministic(
+    const CompactLattice& clat,
+    fst::DeterministicOnDemandFst<fst::StdArc>* det_fst,
+    CompactLattice* composed_clat) {
+  // StdFst::Arc and CompactLatticeArc has the same StateId type.
+  typedef fst::StdArc::StateId StateId;
+  typedef fst::StdArc::Weight Weight1;
+  typedef CompactLatticeArc::Weight Weight2;
+  typedef std::pair<StateId, StateId> StatePair;
+  typedef unordered_map<StatePair, StateId, PairHasher<StateId> > MapType;
+  typedef MapType::iterator IterType;
+
+  // Empties the output FST.
+  KALDI_ASSERT(composed_clat != NULL);
+  composed_clat->DeleteStates();
+
+  MapType state_map;
+  std::queue<StatePair> state_queue;
+
+  // Sets start state in <composed_clat>.
+  StateId start_state = composed_clat->AddState();
+  StatePair start_pair(clat.Start(), det_fst->Start());
+  composed_clat->SetStart(start_state);
+  state_queue.push(start_pair);
+  std::pair<IterType, bool> result =
+      state_map.insert(std::make_pair(start_pair, start_state));
+  KALDI_ASSERT(result.second == true);
+
+  // Starts composition here.
+  while (!state_queue.empty()) {
+    // Gets the first state in the queue.
+    StatePair s = state_queue.front();
+    StateId s1 = s.first;
+    StateId s2 = s.second;
+    state_queue.pop();
+
+    // If the product of the final weights of the two states is not zero, then
+    // we should create final state in fst_composed. We compute the product
+    // manually since this is more efficient.
+    Weight2 final_weight(LatticeWeight(clat.Final(s1).Weight().Value1() +
+                                       det_fst->Final(s2).Value(),
+                                       clat.Final(s1).Weight().Value2()),
+                         clat.Final(s1).String());
+    if (final_weight != Weight2::Zero()) {
+      KALDI_ASSERT(state_map.find(s) != state_map.end());
+      composed_clat->SetFinal(state_map[s], final_weight);
+    }
+
+    // Loops over pair of edges at s1 and s2.
+    for (fst::ArcIterator<CompactLattice> aiter(clat, s1);
+         !aiter.Done(); aiter.Next()) {
+      const CompactLatticeArc& arc1 = aiter.Value();
+      fst::StdArc arc2;
+      StateId next_state1 = arc1.nextstate, next_state2;
+      bool matched = false;
+
+      if (arc1.olabel == 0) {
+        // If the symbol on <arc1> is <epsilon>, we transit to the next state
+        // for <clat>, but keep <det_fst> at the current state.
+        matched = true;
+        next_state2 = s2;
+      } else {
+        // Otherwise try to find the matched arc in <det_fst>.
+        matched = det_fst->GetArc(s2, arc1.olabel, &arc2);
+        if (matched) {
+          next_state2 = arc2.nextstate;
+        }
+      }
+
+      // If matched arc is found in <det_fst>, then we have to add new arcs to
+      // <composed_clat>.
+      if (matched) {
+        StatePair next_state_pair(next_state1, next_state2);
+        IterType siter = state_map.find(next_state_pair);
+        StateId next_state;
+
+        // Adds composed state to <state_map>.
+        if (siter == state_map.end()) {
+          // If the composed state has not been created yet, create it.
+          next_state = composed_clat->AddState();
+          std::pair<const StatePair, StateId> next_state_map(next_state_pair,
+                                                             next_state);
+          std::pair<IterType, bool> result = state_map.insert(next_state_map);
+          KALDI_ASSERT(result.second);
+          state_queue.push(next_state_pair);
+        } else {
+          // If the combposed state is already in <state_map>, we can directly
+          // use that.
+          next_state = siter->second;
+        }
+
+        // Adds arc to <composed_clat>.
+        if (arc1.olabel == 0) {
+          composed_clat->AddArc(state_map[s],
+                                CompactLatticeArc(0, 0,
+                                                  arc1.weight, next_state));
+        } else {
+          Weight2 composed_weight(
+              LatticeWeight(arc1.weight.Weight().Value1() +
+                            arc2.weight.Value(),
+                            arc1.weight.Weight().Value2()),
+              arc1.weight.String());
+          composed_clat->AddArc(state_map[s],
+                                CompactLatticeArc(arc1.ilabel, arc1.olabel,
+                                                  composed_weight, next_state));
+        }
+      }
+    }
+  }
+  fst::Connect(composed_clat);
+}
+}
+}  // namespace kaldi
diff --git a/src/ctc/lattice-functions.h b/src/ctc/lattice-functions.h
new file mode 100644
index 0000000..ee9605b
--- /dev/null
+++ b/src/ctc/lattice-functions.h
@@ -0,0 +1,345 @@
+// lat/lattice-functions.h
+
+// Copyright 2009-2012   Saarland University (author: Arnab Ghoshal)
+//           2012-2013   Johns Hopkins University (Author: Daniel Povey);
+//                       Bagher BabaAli
+//                2014   Guoguo Chen
+
+// See ../../COPYING for clarification regarding multiple authors
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//  http://www.apache.org/licenses/LICENSE-2.0
+//
+// THIS CODE IS PROVIDED *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+// KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
+// WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
+// MERCHANTABLITY OR NON-INFRINGEMENT.
+// See the Apache 2 License for the specific language governing permissions and
+// limitations under the License.
+
+
+#ifndef KALDI_CTC_LATTICE_FUNCTIONS_H_
+#define KALDI_CTC_LATTICE_FUNCTIONS_H_
+
+#include <vector>
+#include <map>
+
+#include "base/kaldi-common.h"
+#include "ctc/posterior.h"
+#include "fstext/fstext-lib.h"
+#include "hmm/transition-model.h"
+#include "lat/kaldi-lattice.h"
+#include "itf/decodable-itf.h"
+
+#include "ctc/cctc-transition-model.h"
+
+
+namespace kaldi {
+namespace ctc {
+
+/// This function iterates over the states of a topologically sorted lattice and
+/// counts the time instance corresponding to each state. The times are returned
+/// in a vector of integers 'times' which is resized to have a size equal to the
+/// number of states in the lattice. The function also returns the maximum time
+/// in the lattice (this will equal the number of frames in the file).
+int32 LatticeStateTimes(const Lattice &lat, std::vector<int32> *times);
+
+/// As LatticeStateTimes, but in the CompactLattice format.  Note: must
+/// be topologically sorted.  Returns length of the utterance in frames, which
+/// may not be the same as the maximum time in the lattice, due to frames
+/// in the final-prob.
+int32 CompactLatticeStateTimes(const CompactLattice &clat,
+                               std::vector<int32> *times);
+
+/// This function does the forward-backward over lattices and computes the
+/// posterior probabilities of the arcs. It returns the total log-probability
+/// of the lattice.  The Posterior quantities contain pairs of (transition-id, weight)
+/// on each frame.
+/// If the pointer "acoustic_like_sum" is provided, this value is set to
+/// the sum over the arcs, of the posterior of the arc times the
+/// acoustic likelihood [i.e. negated acoustic score] on that link.
+/// This is used in combination with other quantities to work out
+/// the objective function in MMI discriminative training.
+BaseFloat LatticeForwardBackward(const Lattice &lat,
+                                 Posterior *arc_post,
+                                 double *acoustic_like_sum = NULL);
+
+// This function is something similar to LatticeForwardBackward(), but it is on
+// the CompactLattice lattice format. Also we only need the alpha in the forward 
+// path, not the posteriors.
+bool ComputeCompactLatticeAlphas(const CompactLattice &lat,
+                                 vector<double> *alpha);
+
+// A sibling of the function CompactLatticeAlphas()... We compute the beta from
+// the backward path here.
+bool ComputeCompactLatticeBetas(const CompactLattice &lat,
+                                vector<double> *beta);
+
+/// Topologically sort the compact lattice if not already topologically sorted.
+/// Will crash if the lattice cannot be topologically sorted.
+void TopSortCompactLatticeIfNeeded(CompactLattice *clat);
+
+
+/// Topologically sort the lattice if not already topologically sorted.
+/// Will crash if lattice cannot be topologically sorted.
+void TopSortLatticeIfNeeded(Lattice *clat);
+
+/// Returns the depth of the lattice, defined as the average number of arcs (or
+/// final-prob strings) crossing any given frame.  Returns 1 for empty lattices.
+/// Requires that clat is topologically sorted!
+BaseFloat CompactLatticeDepth(const CompactLattice &clat,
+                              int32 *num_frames = NULL);
+
+/// This function returns, for each frame, the number of arcs crossing that
+/// frame.
+void CompactLatticeDepthPerFrame(const CompactLattice &clat,
+                                 std::vector<int32> *depth_per_frame);
+
+
+/// This function limits the depth of the lattice, per frame: that means, it
+/// does not allow more than a specified number of arcs active on any given
+/// frame.  This can be used to reduce the size of the "very deep" portions of
+/// the lattice.
+void CompactLatticeLimitDepth(int32 max_arcs_per_frame,
+                              CompactLattice *clat);
+
+
+/// Given a lattice, and a transition model to map pdf-ids to phones,
+/// outputs for each frame the set of phones active on that frame.  If
+/// sil_phones (which must be sorted and uniq) is nonempty, it excludes
+/// phones in this list.
+void LatticeActivePhones(const Lattice &lat, const TransitionModel &trans,
+                         const std::vector<int32> &sil_phones,
+                         std::vector<std::set<int32> > *active_phones);
+
+/// Given a lattice, and a transition model to map pdf-ids to phones,
+/// replace the output symbols (presumably words), with phones; we
+/// use the TransitionModel to work out the phone sequence.  Note
+/// that the phone labels are not exactly aligned with the phone
+/// boundaries.  We put a phone label to coincide with any transition
+/// to the final, nonemitting state of a phone (this state always exists,
+/// we ensure this in HmmTopology::Check()).  This would be the last
+/// transition-id in the phone if reordering is not done (but typically
+/// we do reorder).
+/// Also see PhoneAlignLattice, in phone-align-lattice.h.
+void ConvertLatticeToPhones(const TransitionModel &trans_model,
+                            Lattice *lat);
+
+/// Prunes a lattice or compact lattice.  Returns true on success, false if
+/// there was some kind of failure.
+template<class LatticeType>
+bool PruneLattice(BaseFloat beam, LatticeType *lat);
+
+
+/// Given a lattice, and a transition model to map pdf-ids to phones,
+/// replace the sequences of transition-ids with sequences of phones.
+/// Note that this is different from ConvertLatticeToPhones, in that
+/// we replace the transition-ids not the words.
+void ConvertCompactLatticeToPhones(const TransitionModel &trans_model,
+                                   CompactLattice *clat);
+
+/// Boosts LM probabilities by b * [number of frame errors]; equivalently, adds
+/// -b*[number of frame errors] to the graph-component of the cost of each arc/path.
+/// There is a frame error if a particular transition-id on a particular frame
+/// corresponds to a phone not matching transcription's alignment for that frame.
+/// This is used in "margin-inspired" discriminative training, esp. Boosted MMI.
+/// The TransitionModel is used to map transition-ids in the lattice
+/// input-side to phones; the phones appearing in
+/// "silence_phones" are treated specially in that we replace the frame error f
+/// (either zero or 1) for a frame, with the minimum of f or max_silence_error.
+/// For the normal recipe, max_silence_error would be zero.
+/// Returns true on success, false if there was some kind of mismatch.
+/// At input, silence_phones must be sorted and unique.
+bool LatticeBoost(const TransitionModel &trans,
+                  const std::vector<int32> &alignment,
+                  const std::vector<int32> &silence_phones,
+                  BaseFloat b,
+                  BaseFloat max_silence_error,
+                  Lattice *lat);
+
+bool LatticeBoostCctc(const ctc::CctcTransitionModel &trans,
+                  const std::vector<int32> &alignment,
+                  const std::vector<int32> &silence_phones,
+                  BaseFloat b,
+                  BaseFloat max_silence_error,
+                  Lattice *lat);
+
+
+
+/**
+   This function implements either the MPFE (minimum phone frame error) or SMBR
+   (state-level minimum bayes risk) forward-backward, depending on whether
+   "criterion" is "mpfe" or "smbr".  It returns the MPFE
+   criterion of SMBR criterion for this file, and outputs the posteriors (which
+   may be positive or negative) into "arc_post".
+   Note: setting one_silence_class to false gives the old traditional behavior,
+   true gives a possibly improved behavior which will tend to reduce insertions
+   in the trained model.
+*/
+BaseFloat LatticeForwardBackwardMpeVariants(
+    const TransitionModel &trans,
+    const std::vector<int32> &silence_phones,
+    const Lattice &lat,
+    const std::vector<int32> &num_ali,
+    std::string criterion,
+    bool one_silence_class,
+    Posterior *post);
+
+BaseFloat LatticeForwardBackwardMpeVariantsCctc(
+    const ctc::CctcTransitionModel &trans,
+    const std::vector<int32> &silence_phones,
+    const Lattice &lat,
+    const std::vector<int32> &num_ali,
+    std::string criterion,
+    bool one_silence_class,
+    Posterior *post);
+
+
+/**
+   This function can be used to compute posteriors for MMI, with a positive contribution
+   for the numerator and a negative one for the denominator.  This function is not actually
+   used in our normal MMI training recipes, where it's instead done using various command
+   line programs that each do a part of the job.  This function was written for use in
+   neural-net MMI training.
+   If drop_frames is true, it will not compute any posteriors on frames where the num and
+   den have disjoint pdf-ids.
+   If "convert_to_pdf_ids" is true, it will convert the output to be at the level of pdf-ids,
+   not transition-ids.
+   If "cancel" is true, it will cancel out any positive and negative parts from
+   the same transition-id (or pdf-id, if convert_to_pdf_ids == true).
+   It returns the forward-backward likelihood of the lattice. */
+BaseFloat LatticeForwardBackwardMmi(
+    const TransitionModel &trans,
+    const Lattice &lat,
+    const std::vector<int32> &num_ali,
+    bool drop_frames,
+    bool convert_to_pdf_ids,
+    bool cancel,
+    Posterior *arc_post);
+
+BaseFloat LatticeForwardBackwardMmiCctc(
+    const ctc::CctcTransitionModel &tmodel,
+    const Lattice &lat,
+    const std::vector<int32> &num_ali,
+    bool drop_frames,
+    bool convert_to_pdf_ids,
+    bool cancel,
+    Posterior *post);
+
+
+
+/// This function takes a CompactLattice that should only contain a single
+/// linear sequence (e.g. derived from lattice-1best), and that should have been
+/// processed so that the arcs in the CompactLattice align correctly with the
+/// word boundaries (e.g. by lattice-align-words).  It outputs 3 vectors of the
+/// same size, which give, for each word in the lattice (in sequence), the word
+/// label and the begin time and length in frames.  This is done even for zero
+/// (epsilon) words, generally corresponding to optional silence-- if you don't
+/// want them, just ignore them in the output.
+/// This function will print a warning and return false, if the lattice
+/// did not have the correct format (e.g. if it is empty or it is not
+/// linear).
+bool CompactLatticeToWordAlignment(const CompactLattice &clat,
+                                   std::vector<int32> *words,
+                                   std::vector<int32> *begin_times,
+                                   std::vector<int32> *lengths);
+
+/// This function takes a CompactLattice that should only contain a single
+/// linear sequence (e.g. derived from lattice-1best), and that should have been
+/// processed so that the arcs in the CompactLattice align correctly with the
+/// word boundaries (e.g. by lattice-align-words).  It outputs 4 vectors of the
+/// same size, which give, for each word in the lattice (in sequence), the word
+/// label, the begin time and length in frames, and the pronunciation (sequence
+/// of phones).  This is done even for zero words, corresponding to optional
+/// silences -- if you don't want them, just ignore them in the output.
+/// This function will print a warning and return false, if the lattice
+/// did not have the correct format (e.g. if it is empty or it is not
+/// linear).
+bool CompactLatticeToWordProns(
+    const TransitionModel &tmodel,
+    const CompactLattice &clat,
+    std::vector<int32> *words,
+    std::vector<int32> *begin_times,
+    std::vector<int32> *lengths,
+    std::vector<std::vector<int32> > *prons,
+    std::vector<std::vector<int32> > *phone_lengths);
+
+
+/// A form of the shortest-path/best-path algorithm that's specially coded for
+/// CompactLattice.  Requires that clat be acyclic.
+void CompactLatticeShortestPath(const CompactLattice &clat,
+                                CompactLattice *shortest_path);
+
+/// This function add the word insertion penalty to graph score of each word
+/// in the compact lattice
+void AddWordInsPenToCompactLattice(BaseFloat word_ins_penalty,
+                                   CompactLattice *clat);
+
+/// This function *adds* the negated scores obtained from the Decodable object,
+/// to the acoustic scores on the arcs.  If you want to replace them, you should
+/// use ScaleCompactLattice to first set the acoustic scores to zero.  Returns
+/// true on success, false on error (typically some kind of mismatched inputs).
+bool RescoreCompactLattice(DecodableInterface *decodable,
+                           CompactLattice *clat);
+
+
+/// This function returns the number of words in the longest sentence in a
+/// CompactLattice (i.e. the the maximum of any path, of the count of
+/// olabels on that path).
+int32 LongestSentenceLength(const Lattice &lat);
+
+/// This function returns the number of words in the longest sentence in a
+/// CompactLattice, i.e. the the maximum of any path, of the count of
+/// labels on that path... note, in CompactLattice, the ilabels and olabels
+/// are identical because it is an acceptor.
+int32 LongestSentenceLength(const CompactLattice &lat);
+
+
+/// This function is like RescoreCompactLattice, but it is modified to avoid
+/// computing probabilities on most frames where all the pdf-ids are the same.
+/// (it needs the transition-model to work out whether two transition-ids map to
+/// the same pdf-id, and it assumes that the lattice has transition-ids on it).
+/// The naive thing would be to just set all probabilities to zero on frames
+/// where all the pdf-ids are the same (because this value won't affect the
+/// lattice posterior).  But this would become confusing when we compute
+/// corpus-level diagnostics such as the MMI objective function.  Instead,
+/// imagine speedup_factor = 100 (it must be >= 1.0)... with probability (1.0 /
+/// speedup_factor) we compute those likelihoods and multiply them by
+/// speedup_factor; otherwise we set them to zero.  This gives the right
+/// expected probability so our corpus-level diagnostics will be about right.
+bool RescoreCompactLatticeSpeedup(
+    const TransitionModel &tmodel,
+    BaseFloat speedup_factor,
+    DecodableInterface *decodable,
+    CompactLattice *clat);
+
+
+/// This function *adds* the negated scores obtained from the Decodable object,
+/// to the acoustic scores on the arcs.  If you want to replace them, you should
+/// use ScaleCompactLattice to first set the acoustic scores to zero.  Returns
+/// true on success, false on error (e.g. some kind of mismatched inputs).
+/// The input labels, if nonzero, are interpreted as transition-ids or whatever
+/// other index the Decodable object expects.
+bool RescoreLattice(DecodableInterface *decodable,
+                    Lattice *lat);
+
+/// This function Composes a CompactLattice format lattice with a
+/// DeterministicOnDemandFst<fst::StdFst> format fst, and outputs another
+/// CompactLattice format lattice. The first element (the one that corresponds
+/// to LM weight) in CompactLatticeWeight is used for composition.
+///
+/// Note that the DeterministicOnDemandFst interface is not "const", therefore
+/// we cannot use "const" for <det_fst>.
+void ComposeCompactLatticeDeterministic(
+    const CompactLattice& clat,
+    fst::DeterministicOnDemandFst<fst::StdArc>* det_fst,
+    CompactLattice* composed_clat);
+
+}  // namespace kaldi
+}
+
+#endif  // KALDI_LAT_LATTICE_FUNCTIONS_H_
+
diff --git a/src/ctc/posterior.cc b/src/ctc/posterior.cc
new file mode 100644
index 0000000..4ecd3b7
--- /dev/null
+++ b/src/ctc/posterior.cc
@@ -0,0 +1,516 @@
+// ctc/posterior.cc
+
+// Copyright 2009-2011  Microsoft Corporation
+//           2013-2014  Johns Hopkins University (author: Daniel Povey)
+//                2014  Guoguo Chen
+//                2014  Guoguo Chen
+
+// See ../../COPYING for clarification regarding multiple authors
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//  http://www.apache.org/licenses/LICENSE-2.0
+//
+// THIS CODE IS PROVIDED *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+// KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
+// WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
+// MERCHANTABLITY OR NON-INFRINGEMENT.
+// See the Apache 2 License for the specific language governing permissions and
+// limitations under the License.
+
+#include <vector>
+#include "ctc/posterior.h"
+#include "util/kaldi-table.h"
+#include "util/stl-utils.h"
+
+
+namespace kaldi {
+namespace ctc {
+
+void WritePosterior(std::ostream &os, bool binary, const Posterior &post) {
+  if (binary) {
+    int32 sz = post.size();
+    WriteBasicType(os, binary, sz);
+    for (Posterior::const_iterator iter = post.begin(); iter != post.end(); ++iter) {
+      int32 sz2 = iter->size();
+      WriteBasicType(os, binary, sz2);
+      for (std::vector<std::pair<int32, BaseFloat> >::const_iterator
+               iter2 = iter->begin(); iter2 != iter->end(); ++iter2) {
+        WriteBasicType(os, binary, iter2->first);
+        WriteBasicType(os, binary, iter2->second);
+      }
+    }
+  } else {  // In text-mode, choose a human-friendly, script-friendly format.
+    // format is [ 1235 0.6 12 0.4 ] [ 34 1.0 ] ...
+    // We could have used the same code as in the binary case above,
+    // but this would have resulted in less readable output.
+    for (Posterior::const_iterator iter = post.begin(); iter != post.end(); ++iter) {
+      os << "[ ";
+      for (std::vector<std::pair<int32, BaseFloat> >::const_iterator iter2=iter->begin();
+           iter2 != iter->end();
+           iter2++) {
+        os << iter2->first << ' ' << iter2->second << ' ';
+      }
+      os << "] ";
+    }
+    os << '\n';  // newline terminates the Posterior.
+  }
+  if (!os.good())
+    KALDI_ERR << "Output stream error writing Posterior.";
+}
+
+void ReadPosterior(std::istream &is, bool binary, Posterior *post) {
+  post->clear();
+  if (binary) {
+    int32 sz;
+    ReadBasicType(is, true, &sz);
+    if (sz < 0 || sz > 10000000)
+      KALDI_ERR << "Reading posterior: got negative or improbably large size"
+                << sz;
+    post->resize(sz);
+    for (Posterior::iterator iter = post->begin(); iter != post->end(); ++iter) {
+      int32 sz2;
+      ReadBasicType(is, true, &sz2);
+      if (sz2 < 0)
+        KALDI_ERR << "Reading posteriors: got negative size";
+      iter->resize(sz2);
+      for (std::vector<std::pair<int32, BaseFloat> >::iterator iter2=iter->begin();
+           iter2 != iter->end();
+           iter2++) {
+        ReadBasicType(is, true, &(iter2->first));
+        ReadBasicType(is, true, &(iter2->second));
+      }
+    }
+  } else {
+    std::string line;
+    getline(is, line);  // This will discard the \n, if present.
+                        // The Posterior is terminated by a newlinhe.
+    if (is.fail())
+      KALDI_ERR << "holder of Posterior: error reading line " << (is.eof() ? "[eof]" : "");
+    std::istringstream line_is(line);
+    while (1) {
+      std::string str;
+      line_is >> std::ws;  // eat up whitespace.
+      if (line_is.eof()) break;
+      line_is >> str;
+      if (str != "[") {
+        int32 str_int;
+        // if str is an integer, we can give a slightly more concrete suggestion
+        // of what might have gone wrong.
+        KALDI_ERR << "Reading Posterior object: expecting [, got '" << str
+                  << (ConvertStringToInteger(str, &str_int) ?
+                      "': did you provide alignments instead of posteriors?" :
+                      "'.");
+      }
+      std::vector<std::pair<int32, BaseFloat> > this_vec;
+      while (1) {
+        line_is >> std::ws;
+        if (line_is.peek() == ']') {
+          line_is.get();
+          break;
+        }
+        int32 i; BaseFloat p;
+        line_is >> i >> p;
+        if (line_is.fail())
+          KALDI_ERR << "Error reading Posterior object (could not get data after \"[\");";
+        this_vec.push_back(std::make_pair(i, p));
+      }
+      post->push_back(this_vec);
+    }
+  }
+}
+
+
+// static
+bool PosteriorHolder::Write(std::ostream &os, bool binary, const T &t) {
+  InitKaldiOutputStream(os, binary);  // Puts binary header if binary mode.
+  try {
+    WritePosterior(os, binary, t);
+    return true;
+  } catch(const std::exception &e) {
+    KALDI_WARN << "Exception caught writing table of posteriors";
+    if (!IsKaldiError(e.what())) { std::cerr << e.what(); }
+    return false;  // Write failure.
+  }
+}
+
+bool PosteriorHolder::Read(std::istream &is) {
+  t_.clear();
+
+  bool is_binary;
+  if (!InitKaldiInputStream(is, &is_binary)) {
+    KALDI_WARN << "Reading Table object, failed reading binary header";
+    return false;
+  }
+  try {
+    ReadPosterior(is, is_binary, &t_);
+    return true;
+  } catch (std::exception &e) {
+    KALDI_WARN << "Exception caught reading table of posteriors";
+    if (!IsKaldiError(e.what())) { std::cerr << e.what(); }
+    t_.clear();
+    return false;
+  }
+}
+
+// static
+bool GaussPostHolder::Write(std::ostream &os, bool binary, const T &t) {
+  InitKaldiOutputStream(os, binary);  // Puts binary header if binary mode.
+  try {
+    // We don't bother making this a one-line format.
+    int32 sz = t.size();
+    WriteBasicType(os, binary, sz);
+    for (GaussPost::const_iterator iter = t.begin(); iter != t.end(); ++iter) {
+      int32 sz2 = iter->size();
+      WriteBasicType(os, binary, sz2);
+      for (std::vector<std::pair<int32, Vector<BaseFloat> > >::const_iterator iter2=iter->begin();
+           iter2 != iter->end();
+           iter2++) {
+        WriteBasicType(os, binary, iter2->first);
+        iter2->second.Write(os, binary);
+      }
+    }
+    if(!binary) os << '\n';
+    return os.good();
+  } catch (const std::exception &e) {
+    KALDI_WARN << "Exception caught writing table of posteriors";
+    if (!IsKaldiError(e.what())) { std::cerr << e.what(); }
+    return false;  // Write failure.
+  }
+}
+
+bool GaussPostHolder::Read(std::istream &is) {
+  t_.clear();
+
+  bool is_binary;
+  if (!InitKaldiInputStream(is, &is_binary)) {
+    KALDI_WARN << "Reading Table object, failed reading binary header";
+    return false;
+  }
+  try {
+    int32 sz;
+    ReadBasicType(is, is_binary, &sz);
+    if (sz < 0)
+      KALDI_ERR << "Reading posteriors: got negative size";
+    t_.resize(sz);
+    for (GaussPost::iterator iter = t_.begin(); iter != t_.end(); ++iter) {
+      int32 sz2;
+      ReadBasicType(is, is_binary, &sz2);
+      if (sz2 < 0)
+        KALDI_ERR << "Reading posteriors: got negative size";
+      iter->resize(sz2);
+      for (std::vector<std::pair<int32, Vector<BaseFloat> > >::iterator
+               iter2=iter->begin();
+           iter2 != iter->end();
+           iter2++) {
+        ReadBasicType(is, is_binary, &(iter2->first));
+        iter2->second.Read(is, is_binary);
+      }
+    }
+    return true;
+  } catch (std::exception &e) {
+    KALDI_WARN << "Exception caught reading table of posteriors";
+    if (!IsKaldiError(e.what())) { std::cerr << e.what(); }
+    t_.clear();
+    return false;
+  }
+}
+
+
+void ScalePosterior(BaseFloat scale, Posterior *post) {
+  if (scale == 1.0) return;
+  for (size_t i = 0; i < post->size(); i++) {
+    if (scale == 0.0) {
+      (*post)[i].clear();
+    } else {
+      for (size_t j = 0; j < (*post)[i].size(); j++)
+        (*post)[i][j].second *= scale;
+    }
+  }
+}
+
+BaseFloat TotalPosterior(const Posterior &post) {
+  double sum =  0.0;
+  size_t T = post.size();
+  for (size_t t = 0; t < T; t++) {
+    size_t I = post[t].size();
+    for (size_t i = 0; i < I; i++) {
+      sum += post[t][i].second;
+    }
+  }
+  return sum;
+}
+
+bool PosteriorEntriesAreDisjoint(
+    const std::vector<std::pair<int32,BaseFloat> > &post_elem1,
+    const std::vector<std::pair<int32,BaseFloat> > &post_elem2) {
+  unordered_set<int32> set1;
+  for (size_t i = 0; i < post_elem1.size(); i++) set1.insert(post_elem1[i].first);
+  for (size_t i = 0; i < post_elem2.size(); i++)
+    if (set1.count(post_elem2[i].first) != 0) return false;
+  return true; // The sets are disjoint.
+}
+
+// For each frame, merges the posteriors in post1 into post2,
+// frame-by-frame, combining any duplicated entries.
+// note: Posterior is vector<vector<pair<int32, BaseFloat> > >
+// Returns the number of frames for which the two posteriors
+// were disjoint (no common transition-ids or whatever index
+// we are using).
+int32 MergePosteriors(const Posterior &post1,
+                      const Posterior &post2,
+                      bool merge,
+                      bool drop_frames,
+                      Posterior *post) {
+  KALDI_ASSERT(post1.size() == post2.size()); // precondition.
+  post->resize(post1.size());
+
+  int32 num_disjoint = 0;
+  for (size_t i = 0; i < post->size(); i++) {
+    (*post)[i].reserve(post1[i].size() + post2[i].size());
+    (*post)[i].insert((*post)[i].end(),
+                      post1[i].begin(), post1[i].end());
+    (*post)[i].insert((*post)[i].end(),
+                      post2[i].begin(), post2[i].end());
+    if (merge) { // combine and sum up entries with same transition-id.
+      MergePairVectorSumming(&((*post)[i])); // This sorts on
+      // the transition-id merges the entries with the same
+      // key (i.e. same .first element; same transition-id), and
+      // gets rid of entries with zero .second element.
+    } else { // just to keep them pretty, merge them.
+      std::sort( (*post)[i].begin(), (*post)[i].end() );
+    }
+    if (PosteriorEntriesAreDisjoint(post1[i], post2[i])) {
+      num_disjoint++;
+      if (drop_frames)
+        (*post)[i].clear();
+    }
+  }
+  return num_disjoint;
+}
+
+void AlignmentToPosterior(const std::vector<int32> &ali,
+                          Posterior *post) {
+  post->clear();
+  post->resize(ali.size());
+  for (size_t i = 0; i < ali.size(); i++) {
+    (*post)[i].resize(1);
+    (*post)[i][0].first = ali[i];
+    (*post)[i][0].second = 1.0;
+  }
+}
+
+struct ComparePosteriorByPdfs {
+  const TransitionModel *tmodel_;
+  ComparePosteriorByPdfs(const TransitionModel &tmodel): tmodel_(&tmodel) {}
+  bool operator() (const std::pair<int32, BaseFloat> &a,
+                   const std::pair<int32, BaseFloat> &b) {
+    if (tmodel_->TransitionIdToPdf(a.first)
+        < tmodel_->TransitionIdToPdf(b.first))
+      return true;
+    else
+      return false;
+  }
+};
+
+void SortPosteriorByPdfs(const TransitionModel &tmodel,
+                         Posterior *post) {
+  ComparePosteriorByPdfs compare(tmodel);
+  for (size_t i = 0; i < post->size(); i++) {
+    sort((*post)[i].begin(), (*post)[i].end(), compare);
+  }
+}
+
+void ConvertPosteriorToPdfs(const TransitionModel &tmodel,
+                            const Posterior &post_in,
+                            Posterior *post_out) {
+  post_out->clear();
+  post_out->resize(post_in.size());
+  for (size_t i = 0; i < post_out->size(); i++) {
+    unordered_map<int32, BaseFloat> pdf_to_post;
+    for (size_t j = 0; j < post_in[i].size(); j++) {
+      int32 tid = post_in[i][j].first,
+          pdf_id = tmodel.TransitionIdToPdf(tid);
+      BaseFloat post = post_in[i][j].second;
+      if (pdf_to_post.count(pdf_id) == 0)
+        pdf_to_post[pdf_id] = post;
+      else
+        pdf_to_post[pdf_id] += post;
+    }
+    (*post_out)[i].reserve(pdf_to_post.size());
+    for (unordered_map<int32, BaseFloat>::const_iterator iter =
+             pdf_to_post.begin(); iter != pdf_to_post.end(); ++iter) {
+      if (iter->second != 0.0)
+        (*post_out)[i].push_back(
+            std::make_pair(iter->first, iter->second));
+    }
+  }
+}
+
+void ConvertPosteriorToPdfsCctc(const ctc::CctcTransitionModel &tmodel,
+                            const Posterior &post_in,
+                            Posterior *post_out) {
+  post_out->clear();
+  post_out->resize(post_in.size());
+  for (size_t i = 0; i < post_out->size(); i++) {
+    unordered_map<int32, BaseFloat> pdf_to_post;
+    for (size_t j = 0; j < post_in[i].size(); j++) {
+      int32 tid = post_in[i][j].first,
+          pdf_id = tmodel.GraphLabelToOutputIndex(tid);
+      BaseFloat post = post_in[i][j].second;
+      if (pdf_to_post.count(pdf_id) == 0)
+        pdf_to_post[pdf_id] = post;
+      else
+        pdf_to_post[pdf_id] += post;
+    }
+    (*post_out)[i].reserve(pdf_to_post.size());
+    for (unordered_map<int32, BaseFloat>::const_iterator iter =
+             pdf_to_post.begin(); iter != pdf_to_post.end(); ++iter) {
+      if (iter->second != 0.0)
+        (*post_out)[i].push_back(
+            std::make_pair(iter->first, iter->second));
+    }
+  }
+}
+
+void ConvertPosteriorToPhones(const TransitionModel &tmodel,
+                              const Posterior &post_in,
+                              Posterior *post_out) {
+  post_out->clear();
+  post_out->resize(post_in.size());
+  for (size_t i = 0; i < post_out->size(); i++) {
+    std::map<int32, BaseFloat> phone_to_post;
+    for (size_t j = 0; j < post_in[i].size(); j++) {
+      int32 tid = post_in[i][j].first,
+          phone_id = tmodel.TransitionIdToPhone(tid);
+      BaseFloat post = post_in[i][j].second;
+      if (phone_to_post.count(phone_id) == 0)
+        phone_to_post[phone_id] = post;
+      else
+        phone_to_post[phone_id] += post;
+    }
+    (*post_out)[i].reserve(phone_to_post.size());
+    for (std::map<int32, BaseFloat>::const_iterator iter =
+             phone_to_post.begin(); iter != phone_to_post.end(); ++iter) {
+      if (iter->second != 0.0)
+        (*post_out)[i].push_back(
+            std::make_pair(iter->first, iter->second));
+    }
+  }
+}
+
+
+void WeightSilencePost(const TransitionModel &trans_model,
+                       const ConstIntegerSet<int32> &silence_set,
+                       BaseFloat silence_scale,
+                       Posterior *post) {
+  for (size_t i = 0; i < post->size(); i++) {
+    std::vector<std::pair<int32, BaseFloat> > this_post;
+    this_post.reserve((*post)[i].size());
+    for (size_t j = 0; j < (*post)[i].size(); j++) {
+      int32 tid = (*post)[i][j].first,
+          phone = trans_model.TransitionIdToPhone(tid);
+      BaseFloat weight = (*post)[i][j].second;
+      if (silence_set.count(phone) != 0) {  // is a silence.
+        if (silence_scale != 0.0)
+          this_post.push_back(std::make_pair(tid, weight*silence_scale));
+      } else {
+        this_post.push_back(std::make_pair(tid, weight));
+      }
+    }
+    (*post)[i].swap(this_post);
+  }
+}
+
+
+void WeightSilencePostDistributed(const TransitionModel &trans_model,
+                                  const ConstIntegerSet<int32> &silence_set,
+                                  BaseFloat silence_scale,
+                                  Posterior *post) {
+  for (size_t i = 0; i < post->size(); i++) {
+    std::vector<std::pair<int32, BaseFloat> > this_post;
+    this_post.reserve((*post)[i].size());
+    BaseFloat sil_weight = 0.0, nonsil_weight = 0.0;   
+    for (size_t j = 0; j < (*post)[i].size(); j++) {
+      int32 tid = (*post)[i][j].first,
+          phone = trans_model.TransitionIdToPhone(tid);
+      BaseFloat weight = (*post)[i][j].second;
+      if (silence_set.count(phone) != 0) sil_weight += weight;
+      else nonsil_weight += weight;
+    }
+    KALDI_ASSERT(sil_weight >= 0.0 && nonsil_weight >= 0.0); // This "distributed"
+    // weighting approach doesn't make sense if we have negative weights.
+    if (sil_weight + nonsil_weight == 0.0) continue;
+    BaseFloat frame_scale = (sil_weight * silence_scale + nonsil_weight) /
+                            (sil_weight + nonsil_weight);
+    if (frame_scale != 0.0) {
+      for (size_t j = 0; j < (*post)[i].size(); j++) {
+        int32 tid = (*post)[i][j].first;
+        BaseFloat weight = (*post)[i][j].second;    
+        this_post.push_back(std::make_pair(tid, weight * frame_scale));
+      }
+    }
+    (*post)[i].swap(this_post);    
+  }
+}
+
+// comparator object that can be used to sort from greatest to
+// least posterior.
+struct CompareReverseSecond {
+  // view this as an "<" operator used for sorting, except it behaves like
+  // a ">" operator on the .second field of the pair because we want the
+  // sort to be in reverse order (greatest to least) on posterior.
+  bool operator() (const std::pair<int32, BaseFloat> &a,
+                   const std::pair<int32, BaseFloat> &b) {
+    return (a.second > b.second);
+  }
+};
+
+BaseFloat VectorToPosteriorEntry(
+    const VectorBase<BaseFloat> &log_likes,
+    int32 num_gselect,
+    BaseFloat min_post,
+    std::vector<std::pair<int32, BaseFloat> > *post_entry) {
+  KALDI_ASSERT(num_gselect > 0 && min_post >= 0 && min_post < 1.0);
+  // we name num_gauss assuming each entry in log_likes represents a Gaussian;
+  // it doesn't matter if they don't.
+  int32 num_gauss = log_likes.Dim();
+  KALDI_ASSERT(num_gauss > 0);
+  if (num_gselect > num_gauss)
+    num_gselect = num_gauss;
+  Vector<BaseFloat> log_likes_normalized(log_likes);
+  BaseFloat ans = log_likes_normalized.ApplySoftMax();
+  std::vector<std::pair<int32, BaseFloat> > temp_post(num_gauss);
+  for (int32 g = 0; g < num_gauss; g++)
+    temp_post[g] = std::pair<int32, BaseFloat>(g, log_likes_normalized(g));
+  CompareReverseSecond compare;
+  // Sort in decreasing order on posterior.  For efficiency we
+  // first do nth_element and then sort, as we only need the part we're
+  // going to output, to be sorted.
+  std::nth_element(temp_post.begin(),
+                   temp_post.begin() + num_gselect, temp_post.end(),
+                   compare);
+  std::sort(temp_post.begin(), temp_post.begin() + num_gselect,
+            compare);
+
+  post_entry->clear();
+  post_entry->insert(post_entry->end(),
+                     temp_post.begin(), temp_post.begin() + num_gselect);
+  while (post_entry->size() > 1 && post_entry->back().second < min_post)
+    post_entry->pop_back();  
+  // Now renormalize to sum to one after pruning.
+  BaseFloat tot = 0.0;
+  size_t size = post_entry->size();
+  for (size_t i = 0; i < size; i++)
+    tot += (*post_entry)[i].second;
+  BaseFloat inv_tot = 1.0 / tot;
+  for (size_t i = 0; i < size; i++)
+    (*post_entry)[i].second *= inv_tot;
+  return ans;
+}
+
+
+} // End namespace kaldi
+}
diff --git a/src/ctc/posterior.h b/src/ctc/posterior.h
new file mode 100644
index 0000000..1ac6e65
--- /dev/null
+++ b/src/ctc/posterior.h
@@ -0,0 +1,231 @@
+// ctc/posterior.h
+
+// Copyright 2009-2011     Microsoft Corporation
+//           2013-2014     Johns Hopkins University (author: Daniel Povey)
+//                2014     Guoguo Chen
+
+
+// See ../../COPYING for clarification regarding multiple authors
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//  http://www.apache.org/licenses/LICENSE-2.0
+//
+// THIS CODE IS PROVIDED *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+// KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
+// WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
+// MERCHANTABLITY OR NON-INFRINGEMENT.
+// See the Apache 2 License for the specific language governing permissions and
+// limitations under the License.
+
+#ifndef KALDI_CTC_POSTERIOR_H_
+#define KALDI_CTC_POSTERIOR_H_
+
+#include "base/kaldi-common.h"
+#include "tree/context-dep.h"
+#include "util/const-integer-set.h"
+#include "util/kaldi-table.h"
+#include "hmm/transition-model.h"
+
+#include "ctc/cctc-transition-model.h"
+
+
+
+namespace kaldi {
+namespace ctc {
+
+
+/// \addtogroup posterior_group
+/// @{
+
+/// Posterior is a typedef for storing acoustic-state (actually, transition-id)
+/// posteriors over an utterance.  The "int32" is a transition-id, and the BaseFloat
+/// is a probability (typically between zero and one).
+typedef std::vector<std::vector<std::pair<int32, BaseFloat> > > Posterior;
+
+/// GaussPost is a typedef for storing Gaussian-level posteriors for an utterance.
+/// the "int32" is a transition-id, and the Vector<BaseFloat> is a vector of
+/// Gaussian posteriors.
+/// WARNING: We changed "int32" from transition-id to pdf-id, and the change is
+/// applied for all programs using GaussPost. This is for efficiency purpose. We
+/// also changed the name slightly from GauPost to GaussPost to reduce the
+/// chance that the change will go un-noticed in downstream code.
+typedef std::vector<std::vector<std::pair<int32, Vector<BaseFloat> > > > GaussPost;
+
+
+// PosteriorHolder is a holder for Posterior, which is
+// std::vector<std::vector<std::pair<int32, BaseFloat> > >
+// This is used for storing posteriors of transition id's for an
+// utterance.
+class PosteriorHolder {
+ public:
+  typedef Posterior T;
+
+  PosteriorHolder() { }
+
+  static bool Write(std::ostream &os, bool binary, const T &t);
+  
+  void Clear() { Posterior tmp; std::swap(tmp, t_); }
+
+  // Reads into the holder.
+  bool Read(std::istream &is);
+  
+  // Kaldi objects always have the stream open in binary mode for
+  // reading.
+  static bool IsReadInBinary() { return true; }
+
+  const T &Value() const { return t_; }
+  
+ private:
+  KALDI_DISALLOW_COPY_AND_ASSIGN(PosteriorHolder);
+  T t_;
+};
+
+
+/// stand-alone function for writing a Posterior.
+void WritePosterior(std::ostream &os, bool binary, const Posterior &post);
+
+/// stand-alone function for reading a Posterior.
+void ReadPosterior(std::istream &os, bool binary, Posterior *post);
+
+
+// GaussPostHolder is a holder for GaussPost, which is
+// std::vector<std::vector<std::pair<int32, Vector<BaseFloat> > > >
+// This is used for storing posteriors of transition id's for an
+// utterance.
+class GaussPostHolder {
+ public:
+  typedef GaussPost T;
+
+  GaussPostHolder() { }
+
+  static bool Write(std::ostream &os, bool binary, const T &t);  
+
+  void Clear() {  GaussPost tmp;  std::swap(tmp, t_); }
+
+  // Reads into the holder.
+  bool Read(std::istream &is);
+  
+  // Kaldi objects always have the stream open in binary mode for
+  // reading.
+  static bool IsReadInBinary() { return true; }
+
+  const T &Value() const { return t_; }
+  
+ private:
+  KALDI_DISALLOW_COPY_AND_ASSIGN(GaussPostHolder);
+  T t_;
+};
+
+
+// Posterior is a typedef: vector<vector<pair<int32, BaseFloat> > >,
+// representing posteriors over (typically) transition-ids for an
+// utterance.
+typedef TableWriter<PosteriorHolder> PosteriorWriter;
+typedef SequentialTableReader<PosteriorHolder> SequentialPosteriorReader;
+typedef RandomAccessTableReader<PosteriorHolder> RandomAccessPosteriorReader;
+
+
+// typedef std::vector<std::vector<std::pair<int32, Vector<BaseFloat> > > > GaussPost;
+typedef TableWriter<GaussPostHolder> GaussPostWriter;
+typedef SequentialTableReader<GaussPostHolder> SequentialGaussPostReader;
+typedef RandomAccessTableReader<GaussPostHolder> RandomAccessGaussPostReader;
+
+
+/// Scales the BaseFloat (weight) element in the posterior entries.
+void ScalePosterior(BaseFloat scale, Posterior *post);
+
+/// Returns the total of all the weights in "post".
+BaseFloat TotalPosterior(const Posterior &post);
+
+/// Returns true if the two lists of pairs have no common .first element.
+bool PosteriorEntriesAreDisjoint(
+    const std::vector<std::pair<int32, BaseFloat> > &post_elem1,
+    const std::vector<std::pair<int32, BaseFloat> > &post_elem2);
+
+
+/// Merge two sets of posteriors, which must have the same length.  If "merge"
+/// is true, it will make a common entry whenever there are duplicated entries,
+/// adding up the weights.  If "drop_frames" is true, for frames where the
+/// two sets of posteriors were originally disjoint, makes no entries for that
+/// frame (relates to frame dropping, or drop_frames, see Vesely et al, ICASSP
+/// 2013).  Returns the number of frames for which the two posteriors were
+/// disjoint (i.e. no common transition-ids or whatever index we are using).
+int32 MergePosteriors(const Posterior &post1,
+                      const Posterior &post2,
+                      bool merge,
+                      bool drop_frames,
+                      Posterior *post);
+
+/// Given a vector of log-likelihoods (typically of Gaussians in a GMM
+/// but could be of pdf-ids), a number gselect >= 1 and a minimum posterior
+/// 0 <= min_post < 1, it gets the posterior for each element of log-likes
+/// by applying Softmax(), then prunes the posteriors using "gselect" and
+/// "min_post" (keeping at least one), and outputs the result into
+/// "post_entry", sorted from greatest to least posterior.
+/// Returns the total log-likelihood (the output of calling ApplySoftMax()
+/// on a copy of log_likes).
+BaseFloat VectorToPosteriorEntry(
+    const VectorBase<BaseFloat> &log_likes,
+    int32 num_gselect,
+    BaseFloat min_post,
+    std::vector<std::pair<int32, BaseFloat> > *post_entry);
+
+/// Convert an alignment to a posterior (with a scale of 1.0 on
+/// each entry).
+void AlignmentToPosterior(const std::vector<int32> &ali,
+                          Posterior *post);
+
+/// Sorts posterior entries so that transition-ids with same pdf-id are next to
+/// each other.
+void SortPosteriorByPdfs(const TransitionModel &tmodel,
+                         Posterior *post);
+
+
+/// Converts a posterior over transition-ids to be a posterior
+/// over pdf-ids.
+void ConvertPosteriorToPdfs(const TransitionModel &tmodel,
+                            const Posterior &post_in,
+                            Posterior *post_out);
+
+void ConvertPosteriorToPdfsCctc(const ctc::CctcTransitionModel &tmodel,
+                            const Posterior &post_in,
+                            Posterior *post_out);
+
+
+/// Converts a posterior over transition-ids to be a posterior
+/// over phones.
+void ConvertPosteriorToPhones(const TransitionModel &tmodel,
+                              const Posterior &post_in,
+                              Posterior *post_out);
+
+/// Weight any silence phones in the posterior (i.e. any phones
+/// in the set "silence_set" by scale "silence_scale".
+/// The interface was changed in Feb 2014 to do the modification
+/// "in-place" rather than having separate input and output.
+void WeightSilencePost(const TransitionModel &trans_model,
+                       const ConstIntegerSet<int32> &silence_set,
+                       BaseFloat silence_scale,
+                       Posterior *post);
+
+/// This is similar to WeightSilencePost, except that on each frame it
+/// works out the amount by which the overall posterior would be reduced,
+/// and scales down everything on that frame by the same amount.  It
+/// has the effect that frames that are mostly silence get down-weighted.
+/// The interface was changed in Feb 2014 to do the modification
+/// "in-place" rather than having separate input and output.
+void WeightSilencePostDistributed(const TransitionModel &trans_model,
+                                  const ConstIntegerSet<int32> &silence_set,
+                                  BaseFloat silence_scale,
+                                  Posterior *post);
+
+/// @} end "addtogroup posterior_group"
+
+
+} // end namespace kaldi
+}
+
+
+#endif
diff --git a/src/ctc/training-graph-compiler.cc b/src/ctc/training-graph-compiler.cc
new file mode 100644
index 0000000..84cbeab
--- /dev/null
+++ b/src/ctc/training-graph-compiler.cc
@@ -0,0 +1,270 @@
+// ctc/training-graph-compiler.cc
+// Copyright 2009-2011 Microsoft Corporation
+
+// See ../../COPYING for clarification regarding multiple authors
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+
+//  http://www.apache.org/licenses/LICENSE-2.0
+
+// THIS CODE IS PROVIDED *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+// KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
+// WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
+// MERCHANTABLITY OR NON-INFRINGEMENT.
+// See the Apache 2 License for the specific language governing permissions and
+// limitations under the License.
+#include "ctc/training-graph-compiler.h"
+#include "hmm/hmm-utils.h" // for GetHTransducer
+#include "ctc/cctc-graph.h"
+
+namespace kaldi {
+namespace ctc {
+
+
+
+//////////////////////////
+
+TrainingGraphCompilerCctc::TrainingGraphCompilerCctc(const CctcTransitionModel &trans_model,
+                                             const ContextDependency &ctx_dep,  // Does not maintain reference to this.
+                                             fst::VectorFst<fst::StdArc> *lex_fst,
+                                             const std::vector<int32> &disambig_syms,
+                                             const TrainingGraphCompilerOptions &opts, 
+                                             BaseFloat phone_lm_weight):
+    trans_model_(trans_model), ctx_dep_(ctx_dep), lex_fst_(lex_fst),
+    disambig_syms_(disambig_syms), opts_(opts), phone_lm_weight_(phone_lm_weight) {
+  using namespace fst;
+  /* const std::vector<int32> &phone_syms = trans_model_.GetPhones();  // needed to create context fst.
+
+  KALDI_ASSERT(!phone_syms.empty());
+  KALDI_ASSERT(IsSortedAndUniq(phone_syms));
+  SortAndUniq(&disambig_syms_);
+  for (int32 i = 0; i < disambig_syms_.size(); i++)
+    if (std::binary_search(phone_syms.begin(), phone_syms.end(),
+                           disambig_syms_[i]))
+      KALDI_ERR << "Disambiguation symbol " << disambig_syms_[i]
+                << " is also a phone.";
+  
+  int32 subseq_symbol = 1 + phone_syms.back();
+  if (!disambig_syms_.empty() && subseq_symbol <= disambig_syms_.back())
+    subseq_symbol = 1 + disambig_syms_.back();
+
+  {
+    int32 N = ctx_dep.ContextWidth(),
+        P = ctx_dep.CentralPosition();
+    if (P != N-1)
+      AddSubsequentialLoop(subseq_symbol, lex_fst_);  // This is needed for
+    // systems with right-context or we will not successfully compose
+    // with C.
+  } 
+  */
+
+  {  // make sure lexicon is olabel sorted.
+    fst::OLabelCompare<fst::StdArc> olabel_comp;
+    fst::ArcSort(lex_fst_, olabel_comp);
+  }
+}
+
+bool TrainingGraphCompilerCctc::CompileGraphFromText(
+    const std::vector<int32> &transcript,
+    fst::VectorFst<fst::StdArc> *out_fst) {
+  using namespace fst;
+  VectorFst<StdArc> word_fst;
+  MakeLinearAcceptor(transcript, &word_fst);
+  return CompileGraph(word_fst, out_fst);
+}
+
+bool TrainingGraphCompilerCctc::CompileGraph(const fst::VectorFst<fst::StdArc> &word_fst,
+                                         fst::VectorFst<fst::StdArc> *out_fst) {
+  using namespace fst;
+  KALDI_ASSERT(lex_fst_ !=NULL);
+  KALDI_ASSERT(out_fst != NULL);
+
+  VectorFst<StdArc> phone2word_fst;
+  // TableCompose more efficient than compose.
+  TableCompose(*lex_fst_, word_fst, &phone2word_fst, &lex_cache_);
+
+  KALDI_ASSERT(phone2word_fst.Start() != kNoStateId);
+  ShiftPhonesAndAddBlanks(&phone2word_fst);
+  CreateCctcDecodingFst(trans_model_, phone_lm_weight_,
+                               phone2word_fst, out_fst);
+  
+
+  /* ContextFst<StdArc> *cfst = NULL;
+  {  // make cfst [ it's expanded on the fly ]
+    const std::vector<int32> &phone_syms = trans_model_.GetPhones();  // needed to create context fst.
+    int32 subseq_symbol = phone_syms.back() + 1;
+    if (!disambig_syms_.empty() && subseq_symbol <= disambig_syms_.back())
+      subseq_symbol = 1 + disambig_syms_.back();
+
+    cfst = new ContextFst<StdArc>(subseq_symbol,
+                                  phone_syms,
+                                  disambig_syms_,
+                                  ctx_dep_.ContextWidth(),
+                                  ctx_dep_.CentralPosition());
+  }
+
+  VectorFst<StdArc> ctx2word_fst;
+  ComposeContextFst(*cfst, phone2word_fst, &ctx2word_fst);
+  // ComposeContextFst is like Compose but faster for this particular Fst type.
+  // [and doesn't expand too many arcs in the ContextFst.]
+
+  KALDI_ASSERT(ctx2word_fst.Start() != kNoStateId);
+
+  HTransducerConfig h_cfg;
+  h_cfg.transition_scale = opts_.transition_scale;
+
+  std::vector<int32> disambig_syms_h; // disambiguation symbols on
+  // input side of H.
+  VectorFst<StdArc> *H = GetHTransducer(cfst->ILabelInfo(),
+                                        ctx_dep_,
+                                        trans_model_,
+                                        h_cfg,
+                                        &disambig_syms_h);
+  
+  VectorFst<StdArc> &trans2word_fst = *out_fst;  // transition-id to word.
+  TableCompose(*H, ctx2word_fst, &trans2word_fst);
+  
+  KALDI_ASSERT(trans2word_fst.Start() != kNoStateId);
+
+  // Epsilon-removal and determinization combined. This will fail if not determinizable.
+  DeterminizeStarInLog(&trans2word_fst);
+
+  if (!disambig_syms_h.empty()) {
+    RemoveSomeInputSymbols(disambig_syms_h, &trans2word_fst);
+    // we elect not to remove epsilons after this phase, as it is
+    // a little slow.
+    if (opts_.rm_eps)
+      RemoveEpsLocal(&trans2word_fst);
+  }
+
+  
+  // Encoded minimization.
+  MinimizeEncoded(&trans2word_fst);
+
+  std::vector<int32> disambig;
+  AddSelfLoops(trans_model_,
+               disambig,
+               opts_.self_loop_scale,
+               opts_.reorder,
+               &trans2word_fst);
+
+  delete H;
+  delete cfst;
+  */
+  return true;
+}
+
+
+bool TrainingGraphCompilerCctc::CompileGraphsFromText(
+    const std::vector<std::vector<int32> > &transcripts,
+    std::vector<fst::VectorFst<fst::StdArc>*> *out_fsts) {
+  using namespace fst;
+  std::vector<const VectorFst<StdArc>* > word_fsts(transcripts.size());
+  for (size_t i = 0; i < transcripts.size(); i++) {
+    VectorFst<StdArc> *word_fst = new VectorFst<StdArc>();
+    MakeLinearAcceptor(transcripts[i], word_fst);
+    word_fsts[i] = word_fst;
+  }    
+  bool ans = CompileGraphs(word_fsts, out_fsts);
+  for (size_t i = 0; i < transcripts.size(); i++)
+    delete word_fsts[i];
+  return ans;
+}
+
+bool TrainingGraphCompilerCctc::CompileGraphs(
+    const std::vector<const fst::VectorFst<fst::StdArc>* > &word_fsts,
+    std::vector<fst::VectorFst<fst::StdArc>* > *out_fsts) {
+
+  using namespace fst;
+  KALDI_ASSERT(lex_fst_ !=NULL);
+  KALDI_ASSERT(out_fsts != NULL && out_fsts->empty());
+  out_fsts->resize(word_fsts.size(), NULL);
+  if (word_fsts.empty()) return true;
+
+  /* ContextFst<StdArc> *cfst = NULL;
+  {  // make cfst [ it's expanded on the fly ]
+    const std::vector<int32> &phone_syms = trans_model_.GetPhones();  // needed to create context fst.
+    int32 subseq_symbol = phone_syms.back() + 1;
+    if (!disambig_syms_.empty() && subseq_symbol <= disambig_syms_.back())
+      subseq_symbol = 1 + disambig_syms_.back();
+
+    cfst = new ContextFst<StdArc>(subseq_symbol,
+                                  phone_syms,
+                                  disambig_syms_,
+                                  ctx_dep_.ContextWidth(),
+                                  ctx_dep_.CentralPosition());
+  } 
+  */
+
+  for (size_t i = 0; i < word_fsts.size(); i++) {
+    VectorFst<StdArc> phone2word_fst;
+    // TableCompose more efficient than compose.
+    TableCompose(*lex_fst_, *(word_fsts[i]), &phone2word_fst, &lex_cache_);
+
+    KALDI_ASSERT(phone2word_fst.Start() != kNoStateId &&
+                 "Perhaps you have words missing in your lexicon?");    
+    ShiftPhonesAndAddBlanks(&phone2word_fst);
+    CreateCctcDecodingFst(trans_model_, phone_lm_weight_,
+                               phone2word_fst, (*out_fsts)[i] );
+   
+    /* VectorFst<StdArc> ctx2word_fst;
+    ComposeContextFst(*cfst, phone2word_fst, &ctx2word_fst);
+    // ComposeContextFst is like Compose but faster for this particular Fst type.
+    // [and doesn't expand too many arcs in the ContextFst.]
+
+    KALDI_ASSERT(ctx2word_fst.Start() != kNoStateId);
+
+    (*out_fsts)[i] = ctx2word_fst.Copy();  // For now this contains the FST with symbols
+    // representing phones-in-context.
+    */
+  }
+
+  /* HTransducerConfig h_cfg;
+  h_cfg.transition_scale = opts_.transition_scale;
+
+  std::vector<int32> disambig_syms_h;
+  VectorFst<StdArc> *H = GetHTransducer(cfst->ILabelInfo(),
+                                        ctx_dep_,
+                                        trans_model_,
+                                        h_cfg,
+                                        &disambig_syms_h);
+
+  for (size_t i = 0; i < out_fsts->size(); i++) {
+    VectorFst<StdArc> &ctx2word_fst = *((*out_fsts)[i]);
+    VectorFst<StdArc> trans2word_fst;
+    TableCompose(*H, ctx2word_fst, &trans2word_fst);
+
+    DeterminizeStarInLog(&trans2word_fst);
+
+    if (!disambig_syms_h.empty()) {
+      RemoveSomeInputSymbols(disambig_syms_h, &trans2word_fst);
+      if (opts_.rm_eps)
+        RemoveEpsLocal(&trans2word_fst);
+    }
+    
+    // Encoded minimization.
+    MinimizeEncoded(&trans2word_fst);
+
+    std::vector<int32> disambig;
+    AddSelfLoops(trans_model_,
+                 disambig,
+                 opts_.self_loop_scale,
+                 opts_.reorder,
+                 &trans2word_fst);
+
+    KALDI_ASSERT(trans2word_fst.Start() != kNoStateId);
+
+    *((*out_fsts)[i]) = trans2word_fst;
+  }
+
+  delete H;
+  delete cfst;
+  */
+  return true;
+}
+
+
+}  // end namespace kaldi
+}
diff --git a/src/ctc/training-graph-compiler.h b/src/ctc/training-graph-compiler.h
new file mode 100644
index 0000000..98cbbdc
--- /dev/null
+++ b/src/ctc/training-graph-compiler.h
@@ -0,0 +1,116 @@
+// ctc/training-graph-compiler.h
+
+// Copyright 2009-2011 Microsoft Corporation
+
+// See ../../COPYING for clarification regarding multiple authors
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+
+//  http://www.apache.org/licenses/LICENSE-2.0
+
+// THIS CODE IS PROVIDED *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+// KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
+// WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
+// MERCHANTABLITY OR NON-INFRINGEMENT.
+// See the Apache 2 License for the specific language governing permissions and
+// limitations under the License.
+#ifndef KALDI_CTC_TRAINING_GRAPH_COMPILER_CCTC_H_
+#define KALDI_CTC_TRAINING_GRAPH_COMPILER_CCTC_H_
+
+#include "base/kaldi-common.h"
+#include "hmm/transition-model.h"
+#include "ctc/cctc-transition-model.h"
+#include "fst/fstlib.h"
+#include "fstext/fstext-lib.h"
+
+
+namespace kaldi {
+namespace ctc {
+
+
+struct TrainingGraphCompilerOptions {
+
+  BaseFloat transition_scale;
+  BaseFloat self_loop_scale;
+  bool rm_eps;
+  bool reorder;  // (Dan-style graphs)
+
+  explicit TrainingGraphCompilerOptions(BaseFloat transition_scale = 1.0,
+                                        BaseFloat self_loop_scale = 1.0,
+                                        bool b = true) :
+      transition_scale(transition_scale),
+      self_loop_scale(self_loop_scale),
+      rm_eps(false),
+      reorder(b) { }
+
+  void Register(OptionsItf *opts) {
+    opts->Register("transition-scale", &transition_scale, "Scale of transition "
+                   "probabilities (excluding self-loops)");
+    opts->Register("self-loop-scale", &self_loop_scale, "Scale of self-loop vs. "
+                   "non-self-loop probability mass ");
+    opts->Register("reorder", &reorder, "Reorder transition ids for greater decoding efficiency.");
+    opts->Register("rm-eps", &rm_eps,  "Remove [most] epsilons before minimization (only applicable "
+                   "if disambig symbols present)");
+  }
+};
+
+
+class TrainingGraphCompilerCctc {
+ public:
+  TrainingGraphCompilerCctc(const CctcTransitionModel &trans_model,  // Maintains reference to this object.
+                        const ContextDependency &ctx_dep,  // And this.
+                        fst::VectorFst<fst::StdArc> *lex_fst,  // Takes ownership of this object.
+                        // It should not contain disambiguation symbols or subsequential symbol,
+                        // but it should contain optional silence.
+                        const std::vector<int32> &disambig_syms, // disambig symbols in phone symbol table.
+                        const TrainingGraphCompilerOptions &opts, 
+                        BaseFloat phone_lm_weight);
+
+
+  /// CompileGraph compiles a single training graph its input is a
+  // weighted acceptor (G) at the word level, its output is HCLG.
+  // Note: G could actually be an acceptor, it would also work.
+  // This function is not const for technical reasons involving the cache.
+  // if not for "table_compose" we could make it const.
+  bool CompileGraph(const fst::VectorFst<fst::StdArc> &word_grammar,
+                    fst::VectorFst<fst::StdArc> *out_fst);
+  
+  // CompileGraphs allows you to compile a number of graphs at the same
+  // time.  This consumes more memory but is faster.
+  bool CompileGraphs(
+      const std::vector<const fst::VectorFst<fst::StdArc> *> &word_fsts,
+      std::vector<fst::VectorFst<fst::StdArc> *> *out_fsts);
+
+  // This version creates an FST from the text and calls CompileGraph.
+  bool CompileGraphFromText(const std::vector<int32> &transcript,
+                            fst::VectorFst<fst::StdArc> *out_fst);
+
+  // This function creates FSTs from the text and calls CompileGraphs.
+  bool CompileGraphsFromText(
+      const std::vector<std::vector<int32> >  &word_grammar,
+      std::vector<fst::VectorFst<fst::StdArc> *> *out_fsts);
+  
+  
+  ~TrainingGraphCompilerCctc() { delete lex_fst_; }
+ private:
+  const CctcTransitionModel &trans_model_;
+  const ContextDependency &ctx_dep_;
+  fst::VectorFst<fst::StdArc> *lex_fst_; // lexicon FST (an input; we take
+  // ownership as we need to modify it).
+  std::vector<int32> disambig_syms_; // disambig symbols (if any) in the phone
+  // symbol table.
+  fst::TableComposeCache<fst::Fst<fst::StdArc> > lex_cache_;  // stores matcher..
+  // this is one of Dan's extensions.
+
+  TrainingGraphCompilerOptions opts_;
+  BaseFloat phone_lm_weight_;
+};
+
+
+
+}
+}// end namespace kaldi.
+
+#endif
diff --git a/src/ctcbin/Makefile b/src/ctcbin/Makefile
index b9d545f..778bab1 100644
--- a/src/ctcbin/Makefile
+++ b/src/ctcbin/Makefile
@@ -12,7 +12,7 @@ BINFILES = ctc-init-transition-model ctc-copy-transition-model \
     nnet3-ctc-shuffle-egs nnet3-ctc-merge-egs nnet3-ctc-train \
     nnet3-ctc-copy nnet3-ctc-info nnet3-ctc-compute-prob \
     nnet3-ctc-latgen-faster ctc-make-decoding-graph \
-    nnet3-ctc-acc-lda-stats nnet3-ctc-combine
+    nnet3-ctc-acc-lda-stats nnet3-ctc-combine compile-train-graphs-cctc nnet3-align-compiled-cctc nnet3-ctc-get-egs-per-utt
 
 # nnet3-ctc-{copy,subset,shuffle,merge}-egs should all be fairly
 # simple copy-and-modify from the corresponding nnet3-*-egs programs.
diff --git a/src/ctcbin/compile-train-graphs-cctc.cc b/src/ctcbin/compile-train-graphs-cctc.cc
new file mode 100644
index 0000000..f19ac98
--- /dev/null
+++ b/src/ctcbin/compile-train-graphs-cctc.cc
@@ -0,0 +1,169 @@
+// bin/compile-train-graphs-cctc.cc
+
+// Copyright 2009-2012  Microsoft Corporation
+//           2012-2015  Johns Hopkins University (Author: Daniel Povey)
+
+// See ../../COPYING for clarification regarding multiple authors
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//  http://www.apache.org/licenses/LICENSE-2.0
+//
+// THIS CODE IS PROVIDED *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+// KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
+// WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
+// MERCHANTABLITY OR NON-INFRINGEMENT.
+// See the Apache 2 License for the specific language governing permissions and
+// limitations under the License.
+
+#include "base/kaldi-common.h"
+#include "util/common-utils.h"
+#include "tree/context-dep.h"
+//#include "hmm/transition-model.h"
+#include "ctc/cctc-transition-model.h"
+#include "fstext/fstext-lib.h"
+#include "ctc/training-graph-compiler.h"
+
+#include "ctc/cctc-graph.h"
+
+int main(int argc, char *argv[]) {
+  try {
+    using namespace kaldi;
+    using namespace fst;
+    typedef kaldi::int32 int32;
+    using fst::SymbolTable;
+    using fst::VectorFst;
+    using fst::StdArc;
+
+    const char *usage =
+        "Creates training graphs (without transition-probabilities, by default)\n"
+        "\n"
+        "Usage:   compile-train-graphs [options] <tree-in> <model-in> <lexicon-fst-in> <transcriptions-rspecifier> <graphs-wspecifier>\n"
+        "e.g.: \n"
+        " compile-train-graphs tree 1.mdl lex.fst ark:train.tra ark:graphs.fsts\n";
+    ParseOptions po(usage);
+
+    ctc::TrainingGraphCompilerOptions gopts;
+    int32 batch_size = 1; //250
+    gopts.transition_scale = 0.0;  // Change the default to 0.0 since we will generally add the
+    // transition probs in the alignment phase (since they change eacm time)
+    gopts.self_loop_scale = 0.0;  // Ditto for self-loop probs.
+    std::string disambig_rxfilename;
+    gopts.Register(&po);
+
+    po.Register("batch-size", &batch_size,
+                "Number of FSTs to compile at a time (more -> faster but uses "
+                "more memory.  E.g. 500");
+    po.Register("read-disambig-syms", &disambig_rxfilename, "File containing "
+                "list of disambiguation symbols in phone symbol table");
+
+    BaseFloat phone_lm_weight = 0.0;
+
+    po.Register("phone-lm-weight", &phone_lm_weight,
+                "The language-model weight to apply to the phone language "
+                "model that the CCTC system was trained with... this would "
+                "normally 0 [the theoretically best value], or positive but "
+                "close to zero.");
+    
+    po.Read(argc, argv);
+
+    if (po.NumArgs() != 5) {
+      po.PrintUsage();
+      exit(1);
+    }
+
+    std::string tree_rxfilename = po.GetArg(1);
+    std::string model_rxfilename = po.GetArg(2);
+    std::string lex_rxfilename = po.GetArg(3);
+    std::string transcript_rspecifier = po.GetArg(4);
+    std::string fsts_wspecifier = po.GetArg(5);
+
+    ContextDependency ctx_dep;  // the tree.
+    ReadKaldiObject(tree_rxfilename, &ctx_dep);
+
+    ctc::CctcTransitionModel trans_model;
+    //ReadKaldiObject(model_rxfilename, &trans_model);
+    {
+      bool binary;
+      Input ki(model_rxfilename, &binary);
+      trans_model.Read(ki.Stream(), binary);
+    }
+
+    // need VectorFst because we will change it by adding subseq symbol.
+    VectorFst<StdArc> *lex_fst = fst::ReadFstKaldi(lex_rxfilename);
+
+    std::vector<int32> disambig_syms;
+    if (disambig_rxfilename != "")
+      if (!ReadIntegerVectorSimple(disambig_rxfilename, &disambig_syms))
+        KALDI_ERR << "fstcomposecontext: Could not read disambiguation symbols from "
+                  << disambig_rxfilename;
+    
+    ctc::TrainingGraphCompilerCctc gc(trans_model, ctx_dep, lex_fst, disambig_syms, gopts, phone_lm_weight);
+
+    lex_fst = NULL;  // we gave ownership to gc.
+
+    SequentialInt32VectorReader transcript_reader(transcript_rspecifier);
+    TableWriter<fst::VectorFstHolder> fst_writer(fsts_wspecifier);
+
+    int num_succeed = 0, num_fail = 0;
+
+    if (batch_size == 1) {  // We treat batch_size of 1 as a special case in order
+      // to test more parts of the code.
+      for (; !transcript_reader.Done(); transcript_reader.Next()) {
+        std::string key = transcript_reader.Key();
+        const std::vector<int32> &transcript = transcript_reader.Value();
+        VectorFst<StdArc> decode_fst;
+
+        if (!gc.CompileGraphFromText(transcript, &decode_fst)) {
+          decode_fst.DeleteStates();  // Just make it empty.
+        }
+        if (decode_fst.Start() != fst::kNoStateId) {
+          num_succeed++;
+          fst_writer.Write(key, decode_fst);
+        } else {
+          KALDI_WARN << "Empty decoding graph for utterance "
+                     << key;
+          num_fail++;
+        }
+      }
+    } else {
+      std::vector<std::string> keys;
+      std::vector<std::vector<int32> > transcripts;
+      while (!transcript_reader.Done()) {
+        keys.clear();
+        transcripts.clear();
+        for (; !transcript_reader.Done() &&
+                static_cast<int32>(transcripts.size()) < batch_size;
+            transcript_reader.Next()) {
+          keys.push_back(transcript_reader.Key());
+          transcripts.push_back(transcript_reader.Value());
+        }
+        std::vector<fst::VectorFst<fst::StdArc>* > fsts;
+        if (!gc.CompileGraphsFromText(transcripts, &fsts)) {
+          KALDI_ERR << "Not expecting CompileGraphs to fail.";
+        }
+        KALDI_ASSERT(fsts.size() == keys.size());
+        for (size_t i = 0; i < fsts.size(); i++) {
+          if (fsts[i]->Start() != fst::kNoStateId) {
+            num_succeed++;
+            fst_writer.Write(keys[i], *(fsts[i]));
+          } else {
+            KALDI_WARN << "Empty decoding graph for utterance "
+                       << keys[i];
+            num_fail++;
+          }
+        }
+        DeletePointers(&fsts);
+      }
+    }
+    KALDI_LOG << "compile-train-graphs: succeeded for " << num_succeed
+              << " graphs, failed for " << num_fail;
+ 
+    return (num_succeed != 0 ? 0 : 1);
+  } catch(const std::exception &e) {
+    std::cerr << e.what();
+    return -1;
+  }
+}
diff --git a/src/ctcbin/nnet3-align-compiled-cctc.cc b/src/ctcbin/nnet3-align-compiled-cctc.cc
new file mode 100644
index 0000000..267c601
--- /dev/null
+++ b/src/ctcbin/nnet3-align-compiled-cctc.cc
@@ -0,0 +1,198 @@
+// ctc3bin/nnet3-align-compiled-cctc.cc
+
+// Copyright 2009-2012  Microsoft Corporation
+//                      Johns Hopkins University (author: Daniel Povey)
+//                2015  Vijayaditya Peddinti
+
+// See ../../COPYING for clarification regarding multiple authors
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//  http://www.apache.org/licenses/LICENSE-2.0
+//
+// THIS CODE IS PROVIDED *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+// KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
+// WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
+// MERCHANTABLITY OR NON-INFRINGEMENT.
+// See the Apache 2 License for the specific language governing permissions and
+// limitations under the License.
+
+#include "base/kaldi-common.h"
+#include "util/common-utils.h"
+#include "gmm/am-diag-gmm.h"
+#include "hmm/transition-model.h"
+#include "hmm/hmm-utils.h"
+#include "fstext/fstext-lib.h"
+#include "decoder/decoder-wrappers.h"
+#include "decoder/training-graph-compiler.h"
+#include "nnet3/nnet-am-decodable-simple.h"
+#include "lat/kaldi-lattice.h"
+
+#include "ctc/cctc-graph.h"
+#include "nnet3/nnet-cctc-decodable-simple.h"
+
+int main(int argc, char *argv[]) {
+  try {
+    using namespace kaldi;
+    using namespace kaldi::nnet3;
+    using namespace kaldi::ctc;
+    typedef kaldi::int32 int32;
+    using fst::SymbolTable;
+    using fst::VectorFst;
+    using fst::StdArc;
+
+    const char *usage =
+        "Align features given nnet3 neural net model\n"
+        "Usage:   nnet3-align-compiled [options] <nnet-in> <graphs-rspecifier> <features-rspecifier> <alignments-wspecifier>\n"
+        "e.g.: \n"
+        " nnet3-align-compiled 1.mdl ark:graphs.fsts scp:train.scp ark:1.ali\n"
+        "or:\n"
+        " compile-train-graphs tree 1.mdl lex.fst ark:train.tra b, ark:- | \\\n"
+        "   nnet3-align-compiled 1.mdl ark:- scp:train.scp t, ark:1.ali\n";
+
+    ParseOptions po(usage);
+    AlignConfig align_config;
+    DecodableNnetCctcSimpleOptions decodable_opts;
+    std::string use_gpu = "yes";
+    BaseFloat acoustic_scale = 1.0;
+    BaseFloat transition_scale = 1.0;
+    BaseFloat self_loop_scale = 1.0;
+
+    std::string ivector_rspecifier,
+        online_ivector_rspecifier,
+        utt2spk_rspecifier;
+    int32 online_ivector_period = 0;
+    align_config.Register(&po);
+    decodable_opts.Register(&po);
+    po.Register("transition-scale", &transition_scale,
+                "Transition-probability scale [relative to acoustics]");
+    po.Register("acoustic-scale", &acoustic_scale,
+                "Scaling factor for acoustic likelihoods");
+    po.Register("self-loop-scale", &self_loop_scale,
+                "Scale of self-loop versus non-self-loop "
+                "log probs [relative to acoustics]");
+    po.Register("ivectors", &ivector_rspecifier, "Rspecifier for "
+                "iVectors as vectors (i.e. not estimated online); per utterance "
+                "by default, or per speaker if you provide the --utt2spk option.");
+    po.Register("online-ivectors", &online_ivector_rspecifier, "Rspecifier for "
+                "iVectors estimated online, as matrices.  If you supply this,"
+                " you must set the --online-ivector-period option.");
+    po.Register("online-ivector-period", &online_ivector_period, "Number of frames "
+                "between iVectors in matrices supplied to the --online-ivectors "
+                "option");
+    po.Read(argc, argv);
+
+    if (po.NumArgs() < 4 || po.NumArgs() > 5) {
+      po.PrintUsage();
+      exit(1);
+    }
+
+    std::string model_in_filename = po.GetArg(1),
+        fst_rspecifier = po.GetArg(2),
+        feature_rspecifier = po.GetArg(3),
+        alignment_wspecifier = po.GetArg(4),
+        scores_wspecifier = po.GetOptArg(5);
+
+    int num_done = 0, num_err = 0, num_retry = 0;
+    double tot_like = 0.0;
+    kaldi::int64 frame_count = 0;
+
+    {
+      CctcTransitionModel trans_model;
+      Nnet nnet;
+      {
+        bool binary;
+        Input input(model_in_filename, &binary);
+        trans_model.Read(input.Stream(), binary);
+        nnet.Read(input.Stream(), binary);
+      }
+
+      RandomAccessBaseFloatMatrixReader online_ivector_reader(
+          online_ivector_rspecifier);
+      RandomAccessBaseFloatVectorReaderMapped ivector_reader(
+          ivector_rspecifier, utt2spk_rspecifier);
+
+
+      SequentialTableReader<fst::VectorFstHolder> fst_reader(fst_rspecifier);
+      RandomAccessBaseFloatMatrixReader feature_reader(feature_rspecifier);
+      Int32VectorWriter alignment_writer(alignment_wspecifier);
+      BaseFloatWriter scores_writer(scores_wspecifier);
+
+
+      for (; !fst_reader.Done(); fst_reader.Next()) {
+        std::string utt = fst_reader.Key();
+        if (!feature_reader.HasKey(utt)) {
+          KALDI_WARN << "No features for utterance " << utt;
+          num_err++;
+          continue;
+        }
+        const Matrix<BaseFloat> &features = feature_reader.Value(utt);
+        VectorFst<StdArc> decode_fst(fst_reader.Value());
+        fst_reader.FreeCurrent();  // this stops copy-on-write of the fst
+        // by deleting the fst inside the reader, since we're about to mutate
+        // the fst by adding transition probs.
+
+        if (features.NumRows() == 0) {
+          KALDI_WARN << "Zero-length utterance: " << utt;
+          num_err++;
+          continue;
+        }
+
+        const Matrix<BaseFloat> *online_ivectors = NULL;
+        const Vector<BaseFloat> *ivector = NULL;
+        if (!ivector_rspecifier.empty()) {
+          if (!ivector_reader.HasKey(utt)) {
+            KALDI_WARN << "No iVector available for utterance " << utt;
+            num_err++;
+            continue;
+          } else {
+            ivector = &ivector_reader.Value(utt);
+          }
+        }
+        if (!online_ivector_rspecifier.empty()) {
+          if (!online_ivector_reader.HasKey(utt)) {
+            KALDI_WARN << "No online iVector available for utterance " << utt;
+            num_err++;
+            continue;
+          } else {
+            online_ivectors = &online_ivector_reader.Value(utt);
+          }
+        }
+
+        /* {  // Add transition-probs to the FST.
+          std::vector<int32> disambig_syms;  // empty.
+          AddTransitionProbs(trans_model, disambig_syms,
+                             transition_scale, self_loop_scale,
+                             &decode_fst);
+        }
+        */
+
+        DecodableNnetCctcSimple nnet_decodable(
+            decodable_opts, trans_model, nnet,
+            features, ivector, online_ivectors,
+            online_ivector_period);
+
+        AlignUtteranceWrapper(align_config, utt,
+                              decodable_opts.acoustic_scale,
+                              &decode_fst, &nnet_decodable,
+                              &alignment_writer, &scores_writer,
+                              &num_done, &num_err, &num_retry,
+                              &tot_like, &frame_count);
+      }
+      KALDI_LOG << "Overall log-likelihood per frame is "
+                << (tot_like/frame_count)
+                << " over " << frame_count<< " frames.";
+      KALDI_LOG << "Retried " << num_retry << " out of "
+                << (num_done + num_err) << " utterances.";
+      KALDI_LOG << "Done " << num_done << ", errors on " << num_err;
+    }
+    return (num_done != 0 ? 0 : 1);
+  } catch(const std::exception &e) {
+    std::cerr << e.what();
+    return -1;
+  }
+}
+
+
diff --git a/src/ctcbin/nnet3-ctc-get-egs-per-utt.cc b/src/ctcbin/nnet3-ctc-get-egs-per-utt.cc
new file mode 100644
index 0000000..1b05949
--- /dev/null
+++ b/src/ctcbin/nnet3-ctc-get-egs-per-utt.cc
@@ -0,0 +1,311 @@
+// ctcbin/nnet3-ctc-get-egs-per-utt.cc
+
+// Copyright      2015  Johns Hopkins University (author:  Daniel Povey)
+
+// See ../../COPYING for clarification regarding multiple authors
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//  http://www.apache.org/licenses/LICENSE-2.0
+//
+// THIS CODE IS PROVIDED *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+// KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
+// WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
+// MERCHANTABLITY OR NON-INFRINGEMENT.
+// See the Apache 2 License for the specific language governing permissions and
+// limitations under the License.
+
+#include <sstream>
+
+#include "base/kaldi-common.h"
+#include "util/common-utils.h"
+#include "hmm/transition-model.h"
+#include "hmm/posterior.h"
+#include "nnet3/nnet-example.h"
+#include "nnet3/nnet-cctc-example.h"
+
+namespace kaldi {
+namespace nnet3 {
+
+
+static bool ProcessFile(const MatrixBase<BaseFloat> &feats,
+                        const MatrixBase<BaseFloat> *ivector_feats,
+                        const ctc::CctcSupervision &cctc_supervision,
+                        const std::string &utt_id,
+                        bool compress,
+                        int32 left_context,
+                        int32 right_context,
+                        int32 frames_per_eg,
+                        int32 frames_overlap_per_eg,
+                        int32 frame_subsampling_factor,
+                        int64 *num_frames_written,
+                        int64 *num_egs_written,
+                        NnetCctcExampleWriter *example_writer) {
+  int32 num_feature_frames = feats.NumRows(),
+      num_ctc_frames = cctc_supervision.num_frames,
+      num_feature_frames_subsampled = num_feature_frames /
+      frame_subsampling_factor;
+  if (num_ctc_frames != num_feature_frames_subsampled)
+    KALDI_ERR << "Mismatch in num-frames: CTC supervision has "
+              << num_ctc_frames << " versus features/frame_subsampling_factor = "
+              << num_feature_frames << " / " << frame_subsampling_factor
+              << ": check that --frame-subsampling-factor option is set "
+              << "the same as to ctc-get-supervision.";
+
+  KALDI_ASSERT(frames_per_eg % frame_subsampling_factor == 0);
+
+  int32 frames_per_eg_subsampled = frames_per_eg / frame_subsampling_factor,
+      frames_overlap_subsampled = frames_overlap_per_eg / frame_subsampling_factor,
+      frames_shift_subsampled = frames_per_eg_subsampled - frames_overlap_subsampled;
+
+  if (num_feature_frames_subsampled < frames_per_eg_subsampled)
+    return false;
+
+  // we don't do any padding, as it would be a bit tricky to pad the CTC supervision.
+  // Instead we select ranges of frames that fully fit within the file;  these
+  // might slightly overlap with each other or have gaps.
+  std::vector<int32> range_starts_subsampled;
+  ctc::SplitIntoRanges(num_feature_frames_subsampled - frames_overlap_subsampled,
+                       frames_shift_subsampled,
+                       &range_starts_subsampled);
+
+  if (range_starts_subsampled.empty()) {
+    KALDI_WARN << "No output for utterance " << utt_id
+               << " (num-frames=" << num_feature_frames
+               << ") because too short for --frames-per-eg="
+               << frames_per_eg;
+    return false;
+  }
+  ctc::CctcSupervisionSplitter splitter(cctc_supervision);
+
+  for (size_t i = 0; i < range_starts_subsampled.size(); i++) {
+    int32 range_start_subsampled = range_starts_subsampled[i],
+        range_start = range_start_subsampled * frame_subsampling_factor;
+
+    ctc::CctcSupervision supervision_part;
+    splitter.GetFrameRange(range_start_subsampled,
+                           frames_per_eg_subsampled,
+                           &supervision_part);
+    int32 first_frame = 0;  // we shift the time-indexes of all these parts so
+                            // that the supervised part starts from frame 0.
+    NnetCctcSupervision nnet_supervision(supervision_part,
+                                         "output", first_frame,
+                                         frame_subsampling_factor);
+
+    NnetCctcExample nnet_cctc_eg;
+    nnet_cctc_eg.outputs.resize(1);
+    nnet_cctc_eg.outputs[0].Swap(&nnet_supervision);
+    nnet_cctc_eg.inputs.resize(ivector_feats != NULL ? 2 : 1);
+
+    int32 tot_frames = left_context + frames_per_eg + right_context;
+    Matrix<BaseFloat> input_frames(tot_frames, feats.NumCols(), kUndefined);
+
+    // Set up "input_frames".
+    for (int32 j = -left_context; j < frames_per_eg + right_context; j++) {
+      int32 t = range_start + j;
+      if (t < 0) t = 0;
+      if (t >= feats.NumRows()) t = feats.NumRows() - 1;
+      SubVector<BaseFloat> src(feats, t),
+          dest(input_frames, j + left_context);
+      dest.CopyFromVec(src);
+    }
+    NnetIo input_io("input", - left_context,
+                    input_frames);
+    nnet_cctc_eg.inputs[0].Swap(&input_io);
+
+    if (ivector_feats != NULL) {
+      // if applicable, add the iVector feature.
+      // try to get closest frame to middle of window to get
+      // a representative iVector.
+      int32 closest_frame = range_start + frames_per_eg / 2;
+      KALDI_ASSERT(ivector_feats->NumRows() > 0);
+      if (closest_frame >= ivector_feats->NumRows())
+        closest_frame = ivector_feats->NumRows() - 1;
+      Matrix<BaseFloat> ivector(1, ivector_feats->NumCols());
+      ivector.Row(0).CopyFromVec(ivector_feats->Row(closest_frame));
+      NnetIo ivector_io("ivector", 0, ivector);
+      nnet_cctc_eg.inputs[1].Swap(&ivector_io);
+    }
+
+    if (compress)
+      nnet_cctc_eg.Compress();
+
+    std::ostringstream os;
+    //os << utt_id << "-" << range_start;
+    os << utt_id;
+
+    std::string key = os.str(); // key is <utt_id>-<frame_id>
+
+    *num_frames_written += frames_per_eg;
+    *num_egs_written += 1;
+
+    example_writer->Write(key, nnet_cctc_eg);
+  }
+  return true;
+}
+
+void RoundUpNumFrames(int32 frame_subsampling_factor,
+                      int32 *num_frames,
+                      int32 *num_frames_overlap) {
+  if (*num_frames % frame_subsampling_factor != 0) {
+    int32 new_num_frames = frame_subsampling_factor *
+        (*num_frames / frame_subsampling_factor + 1);
+    KALDI_LOG << "Rounding up --num-frames=" << (*num_frames)
+              << " to a multiple of --frame-subsampling-factor="
+              << frame_subsampling_factor
+              << ", now --num-frames=" << new_num_frames;
+    *num_frames = new_num_frames;
+  }
+  if (*num_frames_overlap % frame_subsampling_factor != 0) {
+    int32 new_num_frames_overlap = frame_subsampling_factor *
+        (*num_frames_overlap / frame_subsampling_factor + 1);
+    KALDI_LOG << "Rounding up --num-frames-overlap=" << *num_frames_overlap
+              << " to a multiple of --frame-subsampling-factor="
+              << frame_subsampling_factor
+              << ", now --num-frames=" << new_num_frames_overlap;
+    *num_frames_overlap = new_num_frames_overlap;
+  }
+  if (*num_frames_overlap < 0 || *num_frames_overlap >= *num_frames) {
+    KALDI_ERR << "--num-frames-overlap=" << (*num_frames_overlap) << " < "
+              << "--num-frames=" << (*num_frames);
+  }
+
+
+}
+
+
+} // namespace nnet2
+} // namespace kaldi
+
+int main(int argc, char *argv[]) {
+  try {
+    using namespace kaldi;
+    using namespace kaldi::nnet3;
+    using namespace kaldi::ctc;
+    typedef kaldi::int32 int32;
+    typedef kaldi::int64 int64;
+
+    const char *usage =
+        "Get frame-by-frame examples of data for nnet3+CTC neural network\n"
+        "training.  This involves breaking up utterances into pieces of a\n"
+        "fixed size.  Input will come from ctc-get-supervision.\n"
+        "\n"
+        "Usage:  nnet3-ctc-get-egs [options] <features-rspecifier> "
+        "<ctc-supervision-rspecifier> <egs-wspecifier>\n"
+        "\n"
+        "An example [where $feats expands to the actual features]:\n"
+        "ctc-get-supervision [args] | \\\n"
+        "  nnet3-ctc-get-egs --left-context=25 --right-context=9 --num-frames=20 \"$feats\" ark,s,cs:- \\\n"
+        "  ark:cegs.1.ark\n"
+        "Note: the --frame-subsampling-factor option must be the same as given to\n"
+        "ctc-get-supervision.\n";
+
+    bool compress = true;
+    int32 left_context = 0, right_context = 0, num_frames = 1,
+        num_frames_overlap = 0, length_tolerance = 100,
+        frame_subsampling_factor = 1;
+
+    std::string ivector_rspecifier;
+
+    ParseOptions po(usage);
+    po.Register("compress", &compress, "If true, write egs in "
+                "compressed format (recommended)");
+    po.Register("left-context", &left_context, "Number of frames of left "
+                "context the neural net requires.");
+    po.Register("right-context", &right_context, "Number of frames of right "
+                "context the neural net requires.");
+    po.Register("num-frames", &num_frames, "Number of frames with labels "
+                "that each example contains.  Will be rounded up to a multiple "
+                "of --frame-subsampling-factor.");
+    po.Register("num-frames-overlap", &num_frames_overlap, "Number of frames of "
+                "overlap between each example (could be useful in conjunction "
+                "--min-deriv-time and --max-deriv-time, to avoid wasting data). "
+                "Each time we shift by --num-frames minus --num-frames-overlap.");
+    po.Register("ivectors", &ivector_rspecifier, "Rspecifier of ivector "
+                "features, as a matrix.");
+    po.Register("length-tolerance", &length_tolerance, "Tolerance for "
+                "difference in num-frames between feat and ivector matrices");
+    po.Register("frame-subsampling-factor", &frame_subsampling_factor, "Used "
+                "if the frame-rate in CTC will be less than the frame-rate "
+                "of the original alignment");
+
+    po.Read(argc, argv);
+
+    if (po.NumArgs() != 3) {
+      po.PrintUsage();
+      exit(1);
+    }
+
+    std::string feature_rspecifier = po.GetArg(1),
+        supervision_rspecifier = po.GetArg(2),
+        examples_wspecifier = po.GetArg(3);
+
+    SequentialBaseFloatMatrixReader feat_reader(feature_rspecifier);
+    RandomAccessCctcSupervisionReader supervision_reader(supervision_rspecifier);
+    NnetCctcExampleWriter example_writer(examples_wspecifier);
+    RandomAccessBaseFloatMatrixReader ivector_reader(ivector_rspecifier);
+
+    int32 num_done = 0, num_err = 0;
+    int64 num_frames_written = 0, num_egs_written = 0;
+
+    for (; !feat_reader.Done(); feat_reader.Next()) {
+      std::string key = feat_reader.Key();
+      const Matrix<BaseFloat> &feats = feat_reader.Value();
+      if (!supervision_reader.HasKey(key)) {
+        KALDI_WARN << "No pdf-level posterior for key " << key;
+        num_err++;
+      } else {
+        const ctc::CctcSupervision &supervision = supervision_reader.Value(key);
+        const Matrix<BaseFloat> *ivector_feats = NULL;
+        if (!ivector_rspecifier.empty()) {
+          if (!ivector_reader.HasKey(key)) {
+            KALDI_WARN << "No iVectors for utterance " << key;
+            num_err++;
+            continue;
+          } else {
+            // this address will be valid until we call HasKey() or Value()
+            // again.
+            ivector_feats = &(ivector_reader.Value(key));
+          }
+        }
+        if (ivector_feats != NULL &&
+            (abs(feats.NumRows() - ivector_feats->NumRows()) > length_tolerance
+             || ivector_feats->NumRows() == 0)) {
+          KALDI_WARN << "Length difference between feats " << feats.NumRows()
+                     << " and iVectors " << ivector_feats->NumRows()
+                     << "exceeds tolerance " << length_tolerance;
+          num_err++;
+          continue;
+        }
+        //each example contains all frames
+        num_frames = feats.NumRows();
+        if (num_frames <= 0 || left_context < 0 || right_context < 0 ||
+            length_tolerance < 0 || frame_subsampling_factor <= 0)
+          KALDI_ERR << "One of the integer options is out of the allowed range.";
+        RoundUpNumFrames(frame_subsampling_factor,
+                         &num_frames, &num_frames_overlap);
+
+        if (ProcessFile(feats, ivector_feats, supervision, key, compress,
+                        left_context, right_context, num_frames,
+                        num_frames_overlap, frame_subsampling_factor,
+                        &num_frames_written, &num_egs_written,
+                        &example_writer))
+          num_done++;
+        else
+          num_err++;
+      }
+    }
+
+    KALDI_LOG << "Finished generating nnet3-ctc examples, "
+              << "successfully processed " << num_done
+              << " feature files, wrote " << num_egs_written << " examples, "
+              << " with " << num_frames_written << " egs in total; "
+              << num_err << " files had errors.";
+    return (num_egs_written == 0 || num_err > num_done ? 1 : 0);
+  } catch(const std::exception &e) {
+    std::cerr << e.what() << '\n';
+    return -1;
+  }
+}
diff --git a/src/decoder/Makefile b/src/decoder/Makefile
index e38f5ab..1af651d 100644
--- a/src/decoder/Makefile
+++ b/src/decoder/Makefile
@@ -13,7 +13,7 @@ LIBNAME = kaldi-decoder
 
 ADDLIBS = ../transform/kaldi-transform.a ../tree/kaldi-tree.a ../lat/kaldi-lat.a \
      ../sgmm/kaldi-sgmm.a ../gmm/kaldi-gmm.a ../hmm/kaldi-hmm.a ../util/kaldi-util.a \
-     ../base/kaldi-base.a ../matrix/kaldi-matrix.a 
+     ../base/kaldi-base.a ../matrix/kaldi-matrix.a ../ctc/kaldi-ctc.a
 
 include ../makefiles/default_rules.mk
 
diff --git a/src/decoder/training-graph-compiler.cc b/src/decoder/training-graph-compiler.cc
index d528a48..aaa52ee 100644
--- a/src/decoder/training-graph-compiler.cc
+++ b/src/decoder/training-graph-compiler.cc
@@ -17,6 +17,7 @@
 // limitations under the License.
 #include "decoder/training-graph-compiler.h"
 #include "hmm/hmm-utils.h" // for GetHTransducer
+#include "ctc/cctc-graph.h"
 
 namespace kaldi {
 
@@ -247,5 +248,8 @@ bool TrainingGraphCompiler::CompileGraphs(
   return true;
 }
 
+//////////////////////////
+
+
 
 }  // end namespace kaldi
diff --git a/src/decoder/training-graph-compiler.h b/src/decoder/training-graph-compiler.h
index 36bd62d..e6d0fc8 100644
--- a/src/decoder/training-graph-compiler.h
+++ b/src/decoder/training-graph-compiler.h
@@ -21,6 +21,7 @@
 
 #include "base/kaldi-common.h"
 #include "hmm/transition-model.h"
+#include "ctc/cctc-transition-model.h"
 #include "fst/fstlib.h"
 #include "fstext/fstext-lib.h"
 
diff --git a/src/hmm/Makefile b/src/hmm/Makefile
index 68daf8a..6bc721f 100644
--- a/src/hmm/Makefile
+++ b/src/hmm/Makefile
@@ -9,7 +9,7 @@ OBJFILES = hmm-topology.o transition-model.o hmm-utils.o tree-accu.o posterior.o
 
 LIBNAME = kaldi-hmm
 ADDLIBS = ../tree/kaldi-tree.a ../matrix/kaldi-matrix.a ../util/kaldi-util.a \
-          ../base/kaldi-base.a 
+          ../base/kaldi-base.a ../ctc/kaldi-ctc.a
 
 include ../makefiles/default_rules.mk
 
diff --git a/src/lat/Makefile b/src/lat/Makefile
index 6911899..a22d55b 100644
--- a/src/lat/Makefile
+++ b/src/lat/Makefile
@@ -16,7 +16,7 @@ OBJFILES = kaldi-lattice.o lattice-functions.o word-align-lattice.o \
 LIBNAME = kaldi-lat
 
 ADDLIBS = ../hmm/kaldi-hmm.a ../tree/kaldi-tree.a ../matrix/kaldi-matrix.a \
-          ../util/kaldi-util.a ../base/kaldi-base.a
+          ../util/kaldi-util.a ../base/kaldi-base.a ../ctc/kaldi-ctc.a
 
 
 include ../makefiles/default_rules.mk
diff --git a/src/nnet3/nnet-training-discriminative.cc b/src/nnet3/nnet-training-discriminative.cc
index dbaa609..1432c99 100644
--- a/src/nnet3/nnet-training-discriminative.cc
+++ b/src/nnet3/nnet-training-discriminative.cc
@@ -20,8 +20,8 @@
 #include "nnet3/nnet-training-discriminative.h"
 #include "nnet3/nnet-utils.h"
 #include "nnet3/am-nnet-simple.h"
-#include "hmm/posterior.h"
-#include "lat/lattice-functions.h"
+#include "ctc/posterior.h"
+#include "ctc/lattice-functions.h"
 #include "lat/kaldi-lattice.h"
 #include "matrix/sparse-matrix.h"
 #include "matrix/kaldi-matrix.h"
@@ -34,11 +34,10 @@ namespace nnet3 {
 	
 
 NnetTrainerDiscriminative::NnetTrainerDiscriminative (const NnetTrainerOptions &opts, 
-                                        const AmNnetSimple &am_nnet, 
-                                        const TransitionModel &tmodel, 
+                                        const ctc::CctcTransitionModel &tmodel, 
                                         Nnet *nnet, 
                                         NnetDiscriminativeStats *stats):
-            opts_(opts), am_nnet_(am_nnet), tmodel_(tmodel),
+            opts_(opts), tmodel_(tmodel),
 			nnet_(nnet), stats_(stats), compiler_(*nnet, opts_.optimize_config) {
  
       if (opts_.zero_component_stats) 
@@ -56,13 +55,13 @@ NnetTrainerDiscriminative::NnetTrainerDiscriminative (const NnetTrainerOptions &
 
 }
             
-void NnetTrainerDiscriminative::Train(const NnetExample &eg, 
+void NnetTrainerDiscriminative::Train(const NnetCctcExample &eg, 
                                         const Lattice &clat, 
                                         const std::vector<int32> &num_ali) {
   bool need_model_derivative = true;
   ComputationRequest request;
 
-  GetComputationRequest(*nnet_, eg, need_model_derivative,
+  GetCctcComputationRequest(*nnet_, eg, need_model_derivative,
                         opts_.store_component_stats,
                         &request);
   const NnetComputation *computation = compiler_.Compile(request);
@@ -71,7 +70,7 @@ void NnetTrainerDiscriminative::Train(const NnetExample &eg,
                         *nnet_,
                         (delta_nnet_ == NULL ? nnet_ : delta_nnet_));
   // give the inputs to the computer object.
-  computer.AcceptInputs(*nnet_, eg.io);
+  computer.AcceptInputs(*nnet_, eg.inputs);
   computer.Forward();
   this->ProcessOutputs(eg, clat, num_ali, &computer);
   computer.Backward();
@@ -98,7 +97,7 @@ void NnetTrainerDiscriminative::Train(const NnetExample &eg,
   }
 }
 
-void NnetTrainerDiscriminative::ProcessOutputs(const NnetExample &eg, const Lattice &clat, 
+void NnetTrainerDiscriminative::ProcessOutputs(const NnetCctcExample &eg, const Lattice &clat, 
                             const std::vector<int32> &num_ali, NnetComputer *computer) {
 
 	if (!SplitStringToIntegers(opts_.silence_phones_str, ":", false,
@@ -107,8 +106,8 @@ void NnetTrainerDiscriminative::ProcessOutputs(const NnetExample &eg, const Latt
 				              << opts_.silence_phones_str;
 	}
 	
-  std::vector<NnetIo>::const_iterator iter = eg.io.begin(),
-      end = eg.io.end();
+  std::vector<NnetIo>::const_iterator iter = eg.inputs.begin(),
+      end = eg.inputs.end();
   for (; iter != end; ++iter) {
     const NnetIo &io = *iter;
     int32 node_index = nnet_->GetNodeIndex(io.name);
@@ -118,7 +117,7 @@ void NnetTrainerDiscriminative::ProcessOutputs(const NnetExample &eg, const Latt
       BaseFloat tot_weight, tot_objf;
       bool supply_deriv = true;
       LatticeComputations(stats_,obj_type,
-                          opts_,am_nnet_,tmodel_,
+                          opts_,tmodel_,
                           clat,num_ali,io.features,
                           io.name,supply_deriv, computer,
                           &tot_weight, &tot_objf);
@@ -132,8 +131,7 @@ NnetTrainerDiscriminative::~NnetTrainerDiscriminative() {
 void LatticeComputations (NnetDiscriminativeStats *stats, 
                                   ObjectiveType objective_type,
                                   const NnetTrainerOptions &opts,
-                                  const AmNnetSimple &am_nnet,
-                                  const TransitionModel &tmodel,
+                                  const ctc::CctcTransitionModel &tmodel,
                                   const Lattice &lat,
                                   const std::vector<int32> &num_ali,
                                   const GeneralMatrix &supervision,
@@ -162,18 +160,18 @@ void LatticeComputations (NnetDiscriminativeStats *stats,
 	case kMpe: {
   if (opts.criterion == "mmi" && opts.boost != 0.0) {
     BaseFloat max_silence_error = 0.0;
-    LatticeBoost(tmodel, num_ali, silence_phones,opts.boost, max_silence_error, &clat);
+    ctc::LatticeBoostCctc(tmodel, num_ali, silence_phones,opts.boost, max_silence_error, &clat);
   }
   
   int32 num_frames = num_ali.size();
   stats->tot_t += num_frames;
   stats->tot_t_weighted += num_frames * eg_weight;
   std::vector<CuMatrix<BaseFloat> > forward_data_; 
-  const VectorBase<BaseFloat> &priors = am_nnet.Priors();
+  //const VectorBase<BaseFloat> &priors = am_nnet.Priors();
   const CuMatrixBase<BaseFloat> &posteriors = output;
   KALDI_ASSERT(posteriors.NumRows() == num_frames);
   int32 num_pdfs = posteriors.NumCols();
-  KALDI_ASSERT(num_pdfs == priors.Dim());
+  //KALDI_ASSERT(num_pdfs == priors.Dim());
   
   typedef LatticeArc Arc;
   typedef Arc::StateId StateId;
@@ -193,7 +191,7 @@ void LatticeComputations (NnetDiscriminativeStats *stats,
 
   if (opts.criterion == "mmi") { // need numerator probabilities...
     for (int32 t = 0; t < num_frames; t++) {
-      int32 tid = num_ali[t], pdf_id = tmodel.TransitionIdToPdf(tid);
+      int32 tid = num_ali[t], pdf_id = tmodel.GraphLabelToOutputIndex(tid);
       KALDI_ASSERT(pdf_id >= 0 && pdf_id < num_pdfs);
       requested_indexes.push_back(MakePair(t, pdf_id));
 	}
@@ -207,7 +205,7 @@ void LatticeComputations (NnetDiscriminativeStats *stats,
    for (fst::ArcIterator<Lattice> aiter(clat, s); !aiter.Done(); aiter.Next()) {
 	 const Arc &arc = aiter.Value();
 	 if (arc.ilabel != 0) { // input-side has transition-ids, output-side empty
-	   int32 tid = arc.ilabel, pdf_id = tmodel.TransitionIdToPdf(tid);
+	   int32 tid = arc.ilabel, pdf_id = tmodel.GraphLabelToOutputIndex(tid);
 	   requested_indexes.push_back(MakePair(t, pdf_id));
 	 }
    }
@@ -231,7 +229,8 @@ void LatticeComputations (NnetDiscriminativeStats *stats,
 	   num_floored++;
 	 }
 	 int32 pdf_id = requested_indexes[index].second;
-	 BaseFloat pseudo_loglike = Log(post / priors(pdf_id)) * opts.acoustic_scale;
+	 //BaseFloat pseudo_loglike = Log(post / priors(pdf_id)) * opts.acoustic_scale;
+	 BaseFloat pseudo_loglike = Log(post / 1.0) * opts.acoustic_scale;
 	 answers[index] = pseudo_loglike;
    }
    if (num_floored > 0) {
@@ -270,7 +269,7 @@ void LatticeComputations (NnetDiscriminativeStats *stats,
 
 	// Get the MPE or MMI posteriors.
 	Posterior post;
-	stats->tot_den_objf += eg_weight * GetDiscriminativePosteriors(opts,am_nnet,tmodel,supervision,clat,num_ali,&post);
+	stats->tot_den_objf += eg_weight * GetDiscriminativePosteriors(opts,tmodel,supervision,clat,num_ali,&post);
 	ScalePosterior(eg_weight, &post);
 	double tot_num_post = 0.0, tot_den_post = 0.0;
 	  std::vector<MatrixElement<BaseFloat> > sv_labels;
@@ -313,8 +312,7 @@ void LatticeComputations (NnetDiscriminativeStats *stats,
 
 
 double GetDiscriminativePosteriors(const NnetTrainerOptions &opts,
-                                                const AmNnetSimple &am_nnet,
-                                                const TransitionModel &tmodel,
+                                                const ctc::CctcTransitionModel &tmodel,
                                                 const GeneralMatrix &supervision, 
                                                 const Lattice &clat,
                                                 const std::vector<int32> &num_ali,
@@ -328,7 +326,7 @@ double GetDiscriminativePosteriors(const NnetTrainerOptions &opts,
   if (opts.criterion == "mpfe" || opts.criterion == "smbr") {
     Posterior tid_post;
     double ans;
-    ans = LatticeForwardBackwardMpeVariants(tmodel, silence_phones, clat,
+    ans = ctc::LatticeForwardBackwardMpeVariantsCctc(tmodel, silence_phones, clat,
                                             num_ali, opts.criterion,
                                             opts.one_silence_class,
                                             &tid_post);
@@ -338,7 +336,7 @@ double GetDiscriminativePosteriors(const NnetTrainerOptions &opts,
 	//	KALDI_LOG<<"i="<<i<<" num_ali:"<<num_ali[i];
 	//WriteLattice(std::cerr, false, clat);
 	//KALDI_LOG<<"tid_post.size="<<tid_post.size();
-    ConvertPosteriorToPdfs(tmodel, tid_post, post);
+    ctc::ConvertPosteriorToPdfsCctc(tmodel, tid_post, post);
     return ans; // returns the objective function.
   } else {
     KALDI_ASSERT(opts.criterion == "mmi");
@@ -346,7 +344,7 @@ double GetDiscriminativePosteriors(const NnetTrainerOptions &opts,
     // we'll return the denominator-lattice forward backward likelihood,
     // which is one term in the objective function.
 
-     return LatticeForwardBackwardMmi(tmodel, clat, num_ali,
+     return ctc::LatticeForwardBackwardMmiCctc(tmodel, clat, num_ali,
                                          opts.drop_frames, convert_to_pdfs,
                                          cancel, post);
       }
diff --git a/src/nnet3/nnet-training-discriminative.h b/src/nnet3/nnet-training-discriminative.h
index 9954a8b..299cfc9 100644
--- a/src/nnet3/nnet-training-discriminative.h
+++ b/src/nnet3/nnet-training-discriminative.h
@@ -29,6 +29,11 @@
 #include "hmm/transition-model.h"
 #include "lat/kaldi-lattice.h"
 
+#include "ctc/cctc-transition-model.h"
+#include "nnet3/nnet-cctc-example.h"
+
+
+
 namespace kaldi {
 namespace nnet3 {
 
@@ -128,21 +133,19 @@ class NnetTrainerDiscriminative {
  public:
 
   NnetTrainerDiscriminative (const NnetTrainerOptions &opts, 
-                                        const AmNnetSimple &am_nnet, 
-                                        const TransitionModel &tmodel, 
+                                        const ctc::CctcTransitionModel &tmodel, 
                                         Nnet *nnet, 
                                         NnetDiscriminativeStats *stats);
 
-  void Train (const NnetExample &eg, const Lattice &clat, const std::vector<int32> &num_ali);
+  void Train (const NnetCctcExample &eg, const Lattice &clat, const std::vector<int32> &num_ali);
 
   ~NnetTrainerDiscriminative ();
   
  private:
-  void ProcessOutputs(const NnetExample &eg, const Lattice &clat, 
+  void ProcessOutputs(const NnetCctcExample &eg, const Lattice &clat, 
                             const std::vector<int32> &num_ali, NnetComputer *computer);
   const NnetTrainerOptions &opts_;
-  const AmNnetSimple &am_nnet_;
-  const TransitionModel &tmodel_;
+  const ctc::CctcTransitionModel &tmodel_;
   
   Nnet *nnet_;
   Nnet *delta_nnet_;  // Only used if momentum != 0.0.  nnet representing
@@ -194,8 +197,7 @@ class NnetTrainerDiscriminative {
  void LatticeComputations(NnetDiscriminativeStats *stats, 
                                   ObjectiveType objective_type,
                                   const NnetTrainerOptions &opts,
-                                  const AmNnetSimple &am_nnet,
-                                  const TransitionModel &tmodel,
+                                  const ctc::CctcTransitionModel &tmodel,
                                   const Lattice &clat,
                                   const std::vector<int32> &num_ali,
                                   const GeneralMatrix &supervision,
@@ -206,8 +208,7 @@ class NnetTrainerDiscriminative {
                                   BaseFloat *tot_objf);
 
  double GetDiscriminativePosteriors(const NnetTrainerOptions &opts,
-                                                const AmNnetSimple &am_nnet,
-                                                const TransitionModel &tmodel,
+                                                const ctc::CctcTransitionModel &tmodel,
                                                 const GeneralMatrix &supervision, 
                                                 const Lattice &clat,
                                                 const std::vector<int32> &num_ali,
diff --git a/src/nnet3bin/Makefile b/src/nnet3bin/Makefile
index bed7a51..8d1db70 100644
--- a/src/nnet3bin/Makefile
+++ b/src/nnet3bin/Makefile
@@ -8,10 +8,10 @@ LDLIBS += $(CUDA_LDLIBS)
 
 BINFILES = nnet3-init nnet3-info nnet3-get-egs nnet3-get-egs-per-utt nnet3-copy-egs nnet3-subset-egs \
    nnet3-shuffle-egs nnet3-acc-lda-stats nnet3-merge-egs \
-   nnet3-compute-from-egs nnet3-train nnet3-train-discriminative nnet3-am-init nnet3-am-train-transitions nnet3-am-train-transitions-cctc \
+   nnet3-compute-from-egs nnet3-train nnet3-train-discriminative nnet3-am-init nnet3-am-train-transitions \
    nnet3-am-adjust-priors nnet3-am-copy nnet3-compute-prob \
    nnet3-average nnet3-am-info nnet3-combine nnet3-latgen-faster \
-   nnet3-copy nnet3-show-progress nnet3-align-compiled nnet3-align-compiled-cctc \
+   nnet3-copy nnet3-show-progress nnet3-align-compiled \
    nnet3-get-egs-dense-targets nnet3-compute
 
 OBJFILES =
diff --git a/src/nnet3bin/nnet3-align-compiled-cctc.cc b/src/nnet3bin/nnet3-align-compiled-cctc.cc
deleted file mode 100644
index 6e932a8..0000000
--- a/src/nnet3bin/nnet3-align-compiled-cctc.cc
+++ /dev/null
@@ -1,200 +0,0 @@
-// nnet2bin/nnet-align-compiled-cctc.cc
-
-// Copyright 2009-2012  Microsoft Corporation
-//                      Johns Hopkins University (author: Daniel Povey)
-//                2015  Vijayaditya Peddinti
-
-// See ../../COPYING for clarification regarding multiple authors
-//
-// Licensed under the Apache License, Version 2.0 (the "License");
-// you may not use this file except in compliance with the License.
-// You may obtain a copy of the License at
-//
-//  http://www.apache.org/licenses/LICENSE-2.0
-//
-// THIS CODE IS PROVIDED *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
-// KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
-// WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
-// MERCHANTABLITY OR NON-INFRINGEMENT.
-// See the Apache 2 License for the specific language governing permissions and
-// limitations under the License.
-
-#include "base/kaldi-common.h"
-#include "util/common-utils.h"
-#include "gmm/am-diag-gmm.h"
-#include "hmm/transition-model.h"
-#include "hmm/hmm-utils.h"
-#include "fstext/fstext-lib.h"
-#include "decoder/decoder-wrappers.h"
-#include "decoder/training-graph-compiler.h"
-#include "nnet3/nnet-am-decodable-simple.h"
-#include "lat/kaldi-lattice.h"
-
-#include "ctc/cctc-transition-model.h"
-#include "nnet3/nnet-cctc-decodable-simple.h"
-
-int main(int argc, char *argv[]) {
-  try {
-    using namespace kaldi;
-    using namespace kaldi::nnet3;
-    typedef kaldi::int32 int32;
-    using fst::SymbolTable;
-    using fst::VectorFst;
-    using fst::StdArc;
-
-    const char *usage =
-        "Align features given nnet3 neural net model\n"
-        "Usage:   nnet3-align-compiled [options] <ctc-nnet-in> <nnet-in> <graphs-rspecifier> <features-rspecifier> <alignments-wspecifier>\n"
-        "e.g.: \n"
-        " nnet3-align-compiled 1.mdl 2.mdl ark:graphs.fsts scp:train.scp ark:1.ali\n"
-        "or:\n"
-        " compile-train-graphs tree 1.mdl lex.fst ark:train.tra b, ark:- | \\\n"
-        "   nnet3-align-compiled 1.mdl 2.mdl ark:- scp:train.scp t, ark:1.ali\n";
-
-    ParseOptions po(usage);
-    AlignConfig align_config;
-    DecodableNnetCctcSimpleOptions decodable_opts;
-    std::string use_gpu = "yes";
-    BaseFloat acoustic_scale = 1.0;
-    BaseFloat transition_scale = 1.0;
-    BaseFloat self_loop_scale = 1.0;
-
-    std::string ivector_rspecifier,
-        online_ivector_rspecifier,
-        utt2spk_rspecifier;
-    int32 online_ivector_period = 0;
-    align_config.Register(&po);
-    decodable_opts.Register(&po);
-    po.Register("transition-scale", &transition_scale,
-                "Transition-probability scale [relative to acoustics]");
-    po.Register("acoustic-scale", &acoustic_scale,
-                "Scaling factor for acoustic likelihoods");
-    po.Register("self-loop-scale", &self_loop_scale,
-                "Scale of self-loop versus non-self-loop "
-                "log probs [relative to acoustics]");
-    po.Register("ivectors", &ivector_rspecifier, "Rspecifier for "
-                "iVectors as vectors (i.e. not estimated online); per utterance "
-                "by default, or per speaker if you provide the --utt2spk option.");
-    po.Register("online-ivectors", &online_ivector_rspecifier, "Rspecifier for "
-                "iVectors estimated online, as matrices.  If you supply this,"
-                " you must set the --online-ivector-period option.");
-    po.Register("online-ivector-period", &online_ivector_period, "Number of frames "
-                "between iVectors in matrices supplied to the --online-ivectors "
-                "option");
-    po.Read(argc, argv);
-
-    if (po.NumArgs() < 5 || po.NumArgs() > 6) {
-      po.PrintUsage();
-      exit(1);
-    }
-
-    std::string cctc_model_in_filename = po.GetArg(1),
-        model_in_filename = po.GetArg(2),
-        fst_rspecifier = po.GetArg(3),
-        feature_rspecifier = po.GetArg(4),
-        alignment_wspecifier = po.GetArg(5),
-        scores_wspecifier = po.GetOptArg(6);
-
-    int num_done = 0, num_err = 0, num_retry = 0;
-    double tot_like = 0.0;
-    kaldi::int64 frame_count = 0;
-
-    {
-      ctc::CctcTransitionModel cctc_trans_model;
-      TransitionModel trans_model;
-      Nnet nnet;
-      {
-        bool binary;
-        Input ki_cctc(cctc_model_in_filename, &binary);
-        Input ki(model_in_filename, &binary);
-        cctc_trans_model.Read(ki_cctc.Stream(), binary);
-        trans_model.Read(ki.Stream(), binary);
-        nnet.Read(ki_cctc.Stream(), binary);
-      }
-
-      RandomAccessBaseFloatMatrixReader online_ivector_reader(
-          online_ivector_rspecifier);
-      RandomAccessBaseFloatVectorReaderMapped ivector_reader(
-          ivector_rspecifier, utt2spk_rspecifier);
-
-
-      SequentialTableReader<fst::VectorFstHolder> fst_reader(fst_rspecifier);
-      RandomAccessBaseFloatMatrixReader feature_reader(feature_rspecifier);
-      Int32VectorWriter alignment_writer(alignment_wspecifier);
-      BaseFloatWriter scores_writer(scores_wspecifier);
-
-
-      for (; !fst_reader.Done(); fst_reader.Next()) {
-        std::string utt = fst_reader.Key();
-        if (!feature_reader.HasKey(utt)) {
-          KALDI_WARN << "No features for utterance " << utt;
-          num_err++;
-          continue;
-        }
-        const Matrix<BaseFloat> &features = feature_reader.Value(utt);
-        VectorFst<StdArc> decode_fst(fst_reader.Value());
-        fst_reader.FreeCurrent();  // this stops copy-on-write of the fst
-        // by deleting the fst inside the reader, since we're about to mutate
-        // the fst by adding transition probs.
-
-        if (features.NumRows() == 0) {
-          KALDI_WARN << "Zero-length utterance: " << utt;
-          num_err++;
-          continue;
-        }
-
-        const Matrix<BaseFloat> *online_ivectors = NULL;
-        const Vector<BaseFloat> *ivector = NULL;
-        if (!ivector_rspecifier.empty()) {
-          if (!ivector_reader.HasKey(utt)) {
-            KALDI_WARN << "No iVector available for utterance " << utt;
-            num_err++;
-            continue;
-          } else {
-            ivector = &ivector_reader.Value(utt);
-          }
-        }
-        if (!online_ivector_rspecifier.empty()) {
-          if (!online_ivector_reader.HasKey(utt)) {
-            KALDI_WARN << "No online iVector available for utterance " << utt;
-            num_err++;
-            continue;
-          } else {
-            online_ivectors = &online_ivector_reader.Value(utt);
-          }
-        }
-
-        {  // Add transition-probs to the FST.
-          std::vector<int32> disambig_syms;  // empty.
-          AddTransitionProbs(trans_model, disambig_syms,
-                             transition_scale, self_loop_scale,
-                             &decode_fst);
-        }
-
-        DecodableNnetCctcSimple nnet_decodable(
-            decodable_opts, cctc_trans_model, nnet,
-            features, ivector, online_ivectors,
-            online_ivector_period);
-
-        AlignUtteranceWrapper(align_config, utt,
-                              decodable_opts.acoustic_scale,
-                              &decode_fst, &nnet_decodable,
-                              &alignment_writer, &scores_writer,
-                              &num_done, &num_err, &num_retry,
-                              &tot_like, &frame_count);
-      }
-      KALDI_LOG << "Overall log-likelihood per frame is "
-                << (tot_like/frame_count)
-                << " over " << frame_count<< " frames.";
-      KALDI_LOG << "Retried " << num_retry << " out of "
-                << (num_done + num_err) << " utterances.";
-      KALDI_LOG << "Done " << num_done << ", errors on " << num_err;
-    }
-    return (num_done != 0 ? 0 : 1);
-  } catch(const std::exception &e) {
-    std::cerr << e.what();
-    return -1;
-  }
-}
-
-
diff --git a/src/nnet3bin/nnet3-am-train-transitions-cctc.cc b/src/nnet3bin/nnet3-am-train-transitions-cctc.cc
deleted file mode 100644
index 5810729..0000000
--- a/src/nnet3bin/nnet3-am-train-transitions-cctc.cc
+++ /dev/null
@@ -1,147 +0,0 @@
-// nnet3bin/nnet3-am-train-transitions-cctc.cc
-
-// Copyright 2012-2015  Johns Hopkins University (author:  Daniel Povey)
-
-// See ../../COPYING for clarification regarding multiple authors
-//
-// Licensed under the Apache License, Version 2.0 (the "License");
-// you may not use this file except in compliance with the License.
-// You may obtain a copy of the License at
-//
-//  http://www.apache.org/licenses/LICENSE-2.0
-//
-// THIS CODE IS PROVIDED *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
-// KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
-// WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
-// MERCHANTABLITY OR NON-INFRINGEMENT.
-// See the Apache 2 License for the specific language governing permissions and
-// limitations under the License.
-
-#include "base/kaldi-common.h"
-#include "util/common-utils.h"
-#include "hmm/transition-model.h"
-#include "nnet3/am-nnet-simple.h"
-#include "tree/context-dep.h"
-
-namespace kaldi {
-namespace nnet3 {
-void SetPriors(const TransitionModel &tmodel,
-               const Vector<double> &transition_accs,
-               double prior_floor,
-               AmNnetSimple *am_nnet) {
-  //KALDI_ASSERT(tmodel.NumPdfs() == am_nnet->NumPdfs());
-  Vector<BaseFloat> pdf_counts(am_nnet->NumPdfs(), kSetZero);
-  KALDI_ASSERT(transition_accs(0) == 0.0); // There is
-  // no zero transition-id.
-  for (int32 tid = 1; tid < transition_accs.Dim(); tid++) {
-    int32 pdf = tmodel.TransitionIdToPdf(tid);
-    pdf_counts(pdf) += transition_accs(tid);
-  }
-  BaseFloat sum = pdf_counts.Sum();
-  KALDI_ASSERT(sum != 0.0);
-  KALDI_ASSERT(prior_floor > 0.0 && prior_floor < 1.0);
-  pdf_counts.Scale(1.0 / sum);
-  pdf_counts.ApplyFloor(prior_floor);
-  pdf_counts.Scale(1.0 / pdf_counts.Sum()); // normalize again.
-  am_nnet->SetPriors(pdf_counts);
-}               
-
-
-} // namespace nnet3
-} // namespace kaldi
-
-int main(int argc, char *argv[]) {
-  try {
-    using namespace kaldi;
-    using namespace kaldi::nnet3;
-    typedef kaldi::int32 int32;
-
-    const char *usage =
-        "Train the transition probabilities of an nnet3 neural network acoustic model\n"
-        "\n"
-        "Usage:  nnet3-am-train-transitions-cctc [options] <nnet-in> <alignments-rspecifier> <nnet-out>\n"
-        "e.g.:\n"
-        " nnet3-am-train-transitions-cctc 1.nnet \"ark:gunzip -c ali.*.gz|\" 2.nnet\n";
-    
-    bool binary_write = true;
-    bool set_priors = true; // Also set the per-pdf priors in the model.
-    BaseFloat prior_floor = 5.0e-06; // The default was previously 1e-8, but
-                                     // once we had problems with a pdf-id that
-                                     // was not being seen in training, being
-                                     // recognized all the time.  This value
-                                     // seemed to be the smallest prior of the
-                                     // "seen" pdf-ids in one run.
-    MleTransitionUpdateConfig transition_update_config;
-    
-    ParseOptions po(usage);
-    po.Register("binary", &binary_write, "Write output in binary mode");
-    po.Register("set-priors", &set_priors, "If true, also set priors in neural "
-                "net (we divide by these in test time)");
-    po.Register("prior-floor", &prior_floor, "When setting priors, floor for "
-                "priors");
-    transition_update_config.Register(&po);
-    
-    po.Read(argc, argv);
-    
-    if (po.NumArgs() != 3) {
-      po.PrintUsage();
-      exit(1);
-    }
-
-    std::string nnet_rxfilename = po.GetArg(1),
-        ali_rspecifier = po.GetArg(2),
-        nnet_wxfilename = po.GetArg(3);
-    
-    TransitionModel trans_model;
-    AmNnetSimple am_nnet;
-    {
-      bool binary_read;
-      Input ki(nnet_rxfilename, &binary_read);
-      trans_model.Read(ki.Stream(), binary_read);
-      am_nnet.Read(ki.Stream(), binary_read);
-    }
-    
-    Vector<double> transition_accs;
-    trans_model.InitStats(&transition_accs);
-
-    int32 num_done = 0;
-    SequentialInt32VectorReader ali_reader(ali_rspecifier);
-    for (; ! ali_reader.Done(); ali_reader.Next()) {
-      const std::vector<int32> alignment(ali_reader.Value());
-      for (size_t i = 0; i < alignment.size(); i++) {
-        int32 tid = alignment[i];
-        BaseFloat weight = 1.0;
-        trans_model.Accumulate(weight, tid, &transition_accs);
-      }
-      num_done++;
-    }
-    KALDI_LOG << "Accumulated transition stats from " << num_done
-              << " utterances.";
-
-    {
-      BaseFloat objf_impr, count;
-      trans_model.MleUpdate(transition_accs, transition_update_config,
-                            &objf_impr, &count);
-      KALDI_LOG << "Transition model update: average " << (objf_impr/count)
-                << " log-like improvement per frame over " << count
-                << " frames.";
-    }
-
-    if (set_priors) {
-      KALDI_LOG << "Setting priors of pdfs in the model.";
-      SetPriors(trans_model, transition_accs, prior_floor, &am_nnet);
-    }
-    
-    {
-      Output ko(nnet_wxfilename, binary_write);
-      trans_model.Write(ko.Stream(), binary_write);
-      am_nnet.Write(ko.Stream(), binary_write);
-    }
-    KALDI_LOG << "Trained transitions of neural network model and wrote it to "
-              << nnet_wxfilename;
-    return 0;
-  } catch(const std::exception &e) {
-    std::cerr << e.what() << '\n';
-    return -1;
-  }
-}
diff --git a/src/nnet3bin/nnet3-train-discriminative.cc b/src/nnet3bin/nnet3-train-discriminative.cc
index 36b1527..d162d8f 100644
--- a/src/nnet3bin/nnet3-train-discriminative.cc
+++ b/src/nnet3bin/nnet3-train-discriminative.cc
@@ -21,12 +21,16 @@
 #include "util/common-utils.h"
 #include "nnet3/nnet-training-discriminative.h"
 #include "nnet3/nnet-example.h"
-#include "lat/lattice-functions.h"
+#include "ctc/lattice-functions.h"
+
+#include "nnet3/nnet-cctc-example.h"
+
 
 int main(int argc, char *argv[]) {
   try {
     using namespace kaldi;
     using namespace kaldi::nnet3;
+    using namespace ctc;
     typedef kaldi::int32 int32;
     typedef kaldi::int64 int64;
 
@@ -70,23 +74,22 @@ int main(int argc, char *argv[]) {
         examples_rspecifier = po.GetArg(4),
         nnet_wxfilename = po.GetArg(5);
              
-    TransitionModel trans_model;
-    AmNnetSimple am_nnet;
+    ctc::CctcTransitionModel trans_model;
+    Nnet nnet;
     {
-      bool binary_read;
-      Input ki(mdl_rxfilename, &binary_read);
-      trans_model.Read(ki.Stream(), binary_read);
-      am_nnet.Read(ki.Stream(), binary_read);
+      bool binary;
+      Input ki(mdl_rxfilename, &binary);
+      trans_model.Read(ki.Stream(), binary);
+      nnet.Read(ki.Stream(), binary);
     }
-    Nnet nnet = am_nnet.GetNnet();
     NnetDiscriminativeStats stats;
 
     bool ok;
     {
-      NnetTrainerDiscriminative trainer(train_config, am_nnet, trans_model, &nnet, &stats);
+      NnetTrainerDiscriminative trainer(train_config, trans_model, &nnet, &stats);
       SequentialLatticeReader clat_reader(clat_rspecifier);
 	  RandomAccessInt32VectorReader ref_ali_reader(ref_ali_rspecifier);
-	  SequentialNnetExampleReader example_reader(examples_rspecifier);
+	  SequentialNnetCctcExampleReader example_reader(examples_rspecifier);
       
       for (; !example_reader.Done() && !clat_reader.Done(); example_reader.Next(), clat_reader.Next()) {
           std::string utt = example_reader.Key();
